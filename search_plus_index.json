{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址 https://leetcode.com/problemset/all/ 准备刷一道，总结一道。 可以加好友一起交流。 QQ 648917857 微信 17771420231 github 地址：https://github.com/wind-liang/leetcode gitbook 预览地址：http://leetcode.windliang.cc 如果觉得对你有帮助，记得给一个 star 哦 ^ ^ "},"leetCode-1-Two-Sum.html":{"url":"leetCode-1-Two-Sum.html","title":"1. Two Sum","keywords":"","body":"题目描述 （简单难度） 给定一个数组和一个目标和，从数组中找两个数字相加等于目标和，输出这两个数字的下标。 解法一 简单粗暴些，两重循环，遍历所有情况看相加是否等于目标和，如果符合直接输出。 public int[] twoSum1(int[] nums, int target) { int []ans=new int[2]; for(int i=0;i 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 解法二 在上边的解法中看下第二个 for 循环步骤。 for(int j=(i+1);j 我们换个理解方式： for(int j=(i+1);j 第二层 for 循环无非是遍历所有的元素，看哪个元素等于 sub ，时间复杂度为 O（n）。 有没有一种方法，不用遍历就可以找到元素里有没有等于 sub 的？ hash table ！！！ 我们可以把数组的每个元素保存为 hash 的 key，下标保存为 hash 的 value 。 这样只需判断 sub 在不在 hash 的 key 里就可以了，而此时的时间复杂度仅为 O（1）！ 需要注意的地方是，还需判断找到的元素不是当前元素，因为题目里讲一个元素只能用一次。 public int[] twoSum2(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 时间复杂度：比解法一少了一个 for 循环，降为 O（n） 空间复杂度：所谓的空间换时间，这里就能体现出来， 开辟了一个 hash table ，空间复杂度变为 O（n） 解法三 看解法二中，两个 for 循环，他们长的一样，我们当然可以把它合起来。复杂度上不会带来什么变化，变化仅仅是不需要判断是不是当前元素了，因为当前元素还没有添加进 hash 里。 public int[] twoSum3(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 总结 题目比较简单，毕竟暴力的方法也可以解决。唯一闪亮的点就是，时间复杂度从 O（n²）降为 O（n） 的时候，对 hash 的应用，有眼前一亮的感觉。 "},"leetCode-2-Add-Two-Numbers.html":{"url":"leetCode-2-Add-Two-Numbers.html","title":"2. Add Two Numbers","keywords":"","body":"题目描述（中等难度） 就是两个链表表示的数相加，这样就可以实现两个很大的数相加了，无需考虑数值 int ，float 的限制了。 由于自己实现的很乱，直接按答案的讲解了。 图示 链表最左边表示个位数，代表 342 + 465 =807 。 思路 首先每一位相加肯定会产生进位，我们用 carry 表示。进位最大会是 1 ，因为最大的情况是无非是 9 + 9 + 1 = 19 ，也就是两个最大的数相加，再加进位，这样最大是 19 ，不会产生进位 2 。下边是伪代码。 初始化一个节点的头，dummy head ，但是这个头不存储数字。并且将 curr 指向它。 初始化进位 carry 为 0 。 初始化 p 和 q 分别为给定的两个链表 l1 和 l2 的头，也就是个位。 循环，直到 l1 和 l2 全部到达 null 。 设置 x 为 p 节点的值，如果 p 已经到达了 null，设置 x 为 0 。 设置 y 为 q 节点的值，如果 q 已经到达了 null，设置 y 为 0 。 设置 sum = x + y + carry 。 更新 carry = sum / 10 。 创建一个值为 sum mod 10 的节点，并将 curr 的 next 指向它，同时 curr 指向变为当前的新节点。 向前移动 p 和 q 。 判断 carry 是否等于 1 ，如果等于 1 ，在链表末尾增加一个为 1 的节点。 返回 dummy head 的 next ，也就是个位数开始的地方。 初始化的节点 dummy head 没有存储值，最后返回 dummy head 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的 head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。 代码 class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry > 0) { curr.next = new ListNode(carry); } return dummyHead.next; } 时间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。 空间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。而其实新的 List 最大长度是 O（max（m，n））+ 1，因为我们的 head 没有存储值。 扩展 如果链表存储的顺序反过来怎么办？ 我首先想到的是链表先逆序计算，然后将结果再逆序呗，这就转换到我们之前的情况了。不知道还有没有其他的解法。下边分析下单链表逆序的思路。 迭代思想 首先看一下原链表。 总共需要添加两个指针，pre 和 next。 初始化 pre 指向 NULL 。 然后就是迭代的步骤，总共四步，顺序一步都不能错。 next 指向 head 的 next ，防止原链表丢失 head 的 next 从原来链表脱离，指向 pre 。 pre 指向 head head 指向 next 一次迭代就完成了，如果再进行一次迭代就变成下边的样子。 可以看到整个过程无非是把旧链表的 head 取下来，添加的新的链表上。代码怎么写呢？ next = head -> next; //保存 head 的 next , 以防取下 head 后丢失 head -> next = pre; //将 head 从原链表取下来，添加到新链表上 pre = head;// pre 右移 head = next; // head 右移 接下来就是停止条件了，我们再进行一次循环。 可以发现当 head 或者 next 指向 null 的时候，我们就可以停止了。此时将 pre 返回，便是逆序了的链表了。 迭代代码 public ListNode reverseList(ListNode head){ if(head==null) return null; ListNode pre=null; ListNode next; while(head!=null){ next=head.next; head.next=pre; pre=head; head=next; } return pre; } 递归思想 首先假设我们实现了将单链表逆序的函数，ListNode reverseListRecursion(ListNode head) ，传入链表头，返回逆序后的链表头。 接着我们确定如何把问题一步一步的化小，我们可以这样想。 把 head 结点拿出来，剩下的部分我们调用函数 reverseListRecursion ，这样剩下的部分就逆序了，接着我们把 head 结点放到新链表的尾部就可以了。这就是整个递归的思想了。 ​ head 结点拿出来 剩余部分调用逆序函数 reverseListRecursion ，并得到了 newhead 将 2 指向 1 ，1 指向 null，将 newhead 返回即可。 找到递归出口 当然就是如果结点的个数是一个，那么逆序的话还是它本身，直接 return 就够了。怎么判断结点个数是不是一个呢？它的 next 等于 null 就说明是一个了。但如果传进来的本身就是 null，那么直接找它的 next 会报错，所以先判断传进来的是不是 null ，如果是，也是直接返回就可以了。 代码 public ListNode reverseListRecursion(ListNode head){ ListNode newHead; if(head==null||head.next==null ){ return head; } newHead=reverseListRecursion(head.next); //head.next 作为剩余部分的头指针 head.next.next=head; //head.next 代表新链表的尾，将它的 next 置为 head，就是将 head 加到最后了。 head.next=null; return newHead; } "},"leetCode-3-Longest-Substring-Without-Repeating-Characters.html":{"url":"leetCode-3-Longest-Substring-Without-Repeating-Characters.html","title":"3. Longest Substring Without Repeating Characters","keywords":"","body":"题目描述（中等难度） 给定一个字符串，找到没有重复字符的最长子串，返回它的长度。 解法一 简单粗暴些，找一个最长子串，那么我们用两个循环穷举所有子串，然后再用一个函数判断该子串中有没有重复的字符。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0;//保存当前得到满足条件的子串的最大值 for (int i = 0; i set = new HashSet<>();//初始化 hash set for (int i = start; i 时间复杂度：两个循环，加上判断子串满足不满足条件的函数中的循环，O（n³）。 空间复杂度：使用了一个 set，判断子串中有没有重复的字符。由于 set 中没有重复的字符，所以最长就是整个字符集，假设字符集的大小为 m ，那么 set 最长就是 m 。另一方面，如果字符串的长度小于 m ，是 n 。那么 set 最长也就是 n 了。综上，空间复杂度为 O（min（m，n））。 解法二 遗憾的是上边的算法没有通过 leetCode，时间复杂度太大，造成了超时。我们怎么来优化一下呢？ 上边的算法中，我们假设当 i 取 0 的时候， j 取 1，判断字符串 str[0,1) 中有没有重复的字符。 j 取 2，判断字符串 str[0,2) 中有没有重复的字符。 j 取 3，判断字符串 str[0,3) 中有没有重复的字符。 j 取 4，判断字符串 str[0,4) 中有没有重复的字符。 做了很多重复的工作，因为如果 str[0,3) 中没有重复的字符，我们不需要再判断整个字符串 str[0,4) 中有没有重复的字符，而只需要判断 str[3] 在不在 str[0,3) 中，不在的话，就表明 str[0,4) 中没有重复的字符。 如果在的话，那么 str[0,5) ，str[0,6) ，str[0,7) 一定有重复的字符，所以此时后边的 j 也不需要继续增加了。i ++ 进入下次的循环就可以了。 此外，我们的 j 也不需要取 j + 1，而只需要从当前的 j 开始就可以了。 综上，其实整个关于 j 的循环我们完全可以去掉了，此时可以理解变成了一个「滑动窗口」。 整体就是橘色窗口在依次向右移动。 判断一个字符在不在字符串中，我们需要可以遍历整个字符串，遍历需要的时间复杂度就是 O（n），加上最外层的 i 的循环，总体复杂度就是 O（n²）。我们可以继续优化，判断字符在不在一个字符串，我们可以将已有的字符串存到 Hash 里，这样的时间复杂度是 O（1），总的时间复杂度就变成了 O（n）。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); Set set = new HashSet<>(); int ans = 0, i = 0, j = 0; while (i 时间复杂度：在最坏的情况下，while 循环中的语句会执行 2n 次，例如 abcdefgg，开始的时候 j 一直后移直到到达第二个 g 的时候固定不变 ，然后 i 开始一直后移直到 n ，所以总共执行了 2n 次，时间复杂度为 O（n）。 空间复杂度：和上边的类似，需要一个 Hash 保存子串，所以是 O（min（m，n））。 解法三 继续优化，我们看上边的算法的一种情况。 当 j 指向的 c 存在于前边的子串 abcd 中，此时 i 向前移到 b ,此时子串中仍然含有 c，还得继续移动，所以这里其实可以优化。我们可以一步到位，直接移动到子串 c 的位置的下一位！ 实现这样的话，我们将 set 改为 map ，将字符存为 key ，将对应的下标存到 value 里就实现了。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map map = new HashMap<>(); for (int j = 0, i = 0; j 与解法二相比 由于采取了 i 跳跃的形式，所以 map 之前存的字符没有进行 remove ，所以 if 语句中进行了Math.max ( map.get ( s.charAt ( j ) ) , i )，要确认得到的下标不是 i 前边的。 还有个不同之处是 j 每次循环都进行了自加 1 ，因为 i 的跳跃已经保证了 str[ i , j] 内没有重复的字符串，所以 j 直接可以加 1 。而解法二中，要保持 j 的位置不变，因为不知道和 j 重复的字符在哪个位置。 最后个不同之处是， ans 在每次循环中都进行更新，因为 ans 更新前 i 都进行了更新，已经保证了当前的子串符合条件，所以可以更新 ans 。而解法二中，只有当当前的子串不包含当前的字符时，才进行更新。 时间复杂度：我们将 2n 优化到了 n ，但最终还是和之前一样，O（n）。 空间复杂度：也是一样的，O（min（m，n)）。 解法四 和解法三思路一样，区别的地方在于，我们不用 Hash ，而是直接用数组，字符的 ASCII 码值作为数组的下标，数组存储该字符所在字符串的位置。适用于字符集比较小的情况，因为我们会直接开辟和字符集等大的数组。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; int[] index = new int[128]; for (int j = 0, i = 0; j 和解法 3 不同的地方在于，没有了 if 的判断，因为如果 index[ s.charAt ( j ) ] 不存在的话，它的值会是 0 ，对最终结果不会影响。 时间复杂度：O（n）。 空间复杂度：O（m），m 代表字符集的大小。这次不论原字符串多小，都会利用这么大的空间。 总结 综上，我们一步一步的寻求可优化的地方，对算法进行了优化。又加深了 Hash 的应用，以及利用数组巧妙的实现了 Hash 的作用。 "},"leetCode-4-Median-of-Two-Sorted-Arrays.html":{"url":"leetCode-4-Median-of-Two-Sorted-Arrays.html","title":"4. Median of Two Sorted Arrays","keywords":"","body":"题目描述（困难难度） 已知两个有序数组，找到两个数组合并后的中位数。 解法一 简单粗暴，先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。 代码 public double findMedianSortedArrays(int[] nums1, int[] nums2) { int[] nums; int m = nums1.length; int n = nums2.length; nums = new int[m + n]; if (m == 0) { if (n % 2 == 0) { return (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0; } else { return nums2[n / 2]; } } if (n == 0) { if (m % 2 == 0) { return (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0; } else { return nums1[m / 2]; } } int count = 0; int i = 0, j = 0; while (count != (m + n)) { if (i == m) { while (j != n) { nums[count++] = nums2[j++]; } break; } if (j == n) { while (i != m) { nums[count++] = nums1[i++]; } break; } if (nums1[i] 时间复杂度：遍历全部数组，O（m + n） 空间复杂度：开辟了一个数组，保存合并后的两个数组，O（m + n） 解法二 其实，我们不需要将两个数组真的合并，我们只需要找到中位数在哪里就可以了。 开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了 for 循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。然后在 这里 找到了另一种思路。 首先是怎么将奇数和偶数的情况合并一下。 用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len + 1）/ 2 个数就可以了，如果遍历的话需要遍历 int ( len / 2 ) + 1 次。如果是偶数，我们需要知道第 len / 2 和 len / 2 + 1 个数，也是需要遍历 len / 2 + 1 次。所以遍历的话，奇数和偶数都是 len / 2 + 1 次。 返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right ，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left 。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。 循环中该怎么写，什么时候 A 数组后移，什么时候 B 数组后移。用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart ＜ m && A[aStart] 但如果 B 数组此刻已经没有数字了，继续取数字B [ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 aStart ＜ m && ( bStart >= n || A [ aStart ] 代码 public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; int len = m + n; int left = -1, right = -1; int aStart = 0, bStart = 0; for (int i = 0; i = n || A[aStart] 时间复杂度：遍历 len/2 + 1 次，len = m + n ，所以时间复杂度依旧是 O（m + n）。 空间复杂度：我们申请了常数个变量，也就是 m，n，len，left，right，aStart，bStart 以及 i 。 总共 8 个变量，所以空间复杂度是 O（1）。 解法三 上边的两种思路，时间复杂度都达不到题目的要求 O ( log ( m + n ) )。看到 log ，很明显，我们只有用到二分的方法才能达到。我们不妨用另一种思路，题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。 解法二中，我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k / 2 个数。看下边一个例子。 假设我们要找第 7 小的数字。 我们比较两个数组的第 k / 2 个数字，如果 k 是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 8 和 下边数组中的 3 ，如果哪个小，就表明该数组的前 k / 2 个数字都不是第 k 小数字，所以可以排除。也就是 1，2，3 这三个数字不可能是第 7 小的数字，我们可以把它排除掉。将 1389 和 45678910 两个数组作为新的数组进行比较。 更一般的情况 A [ 1 ]，A [ 2 ]，A [ 3 ]，A [ k / 2] ... ，B[ 1 ]，B [ 2 ]，B [ 3 ]，B[ k / 2] ... ，如果 A [ k / 2 ] A 数组中比 A [ k / 2 ] 小的数有 k / 2 - 1 个，B 数组中，B [ k / 2 ] 比 A [ k / 2 ] 小，假设 B [ k / 2 ] 前边的数字都比 A [ k / 2 ] 小，也只有 k / 2 - 1 个，所以比 A [ k / 2 ] 小的数字最多有 k / 2 - 1 + k / 2 - 1 = k - 2 个，所以 A [ k / 2 ] 最多是第 k - 1 小的数。而比 A [ k / 2 ] 小的数更不可能是第 k 小的数了，所以可以把它们排除。 橙色的部分表示已经去掉的数字。 由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4 。此时两个数组，比较第 2 个数字，3 我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 = 4 ，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 > 4 吧，所以此时将下边的 4 去掉。 由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4 。 所以第 7 小的数字是 4 。 我们每次都是取 k / 2 的数进行比较，有时候可能会遇到数组长度小于 k / 2 的时候。 此时 k / 2 等于 3 ，而上边的数组长度是 2 ，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 由于 2 个元素被排除，所以此时 k = 5 ，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。 从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。 所以我们采用递归的思路，为了防止数组长度小于 k / 2 ，所以每次比较 min ( k / 2，len ( 数组 ) ) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k = 1 或者其中一个数字长度是 0 了。 代码 public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length; int m = nums2.length; int left = (n + m + 1) / 2; int right = (n + m + 2) / 2; //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。 return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5; } private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) { int len1 = end1 - start1 + 1; int len2 = end2 - start2 + 1; //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 if (len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k); if (len1 == 0) return nums2[start2 + k - 1]; if (k == 1) return Math.min(nums1[start1], nums2[start2]); int i = start1 + Math.min(len1, k / 2) - 1; int j = start2 + Math.min(len2, k / 2) - 1; if (nums1[i] > nums2[j]) { return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1)); } else { return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1)); } } 时间复杂度：每进行一次循环，我们就减少 k / 2 个元素，所以时间复杂度是 O（log（k）），而 k = （m + n）/ 2 ，所以最终的复杂也就是 O（log（m + n））。 空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O（1）。 解法四 我们首先理一下中位数的定义是什么 中位数（又称中值，英语：Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。 所以我们只需要将数组进行切。 一个长度为 m 的数组，有 0 到 m 总共 m + 1 个位置可以切。 我们把数组 A 和数组 B 分别在 i 和 j 进行切割。 将 i 的左边和 j 的左边组合成「左半部分」，将 i 的右边和 j 的右边组合成「右半部分」。 当 A 数组和 B 数组的总长度是偶数时，如果我们能够保证 左半部分的长度等于右半部分 i + j = m - i + n - j , 也就是 j = ( m + n ) / 2 - i 左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） 那么，中位数就可以表示如下 （左半部分最大值 + 右半部分最大值 ）/ 2 。 （max ( A [ i - 1 ] , B [ j - 1 ]）+ min ( A [ i ] , B [ j ]）） / 2 当 A 数组和 B 数组的总长度是奇数时，如果我们能够保证 左半部分的长度比右半部分大 1 i + j = m - i + n - j + 1也就是 j = ( m + n + 1) / 2 - i 左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） 那么，中位数就是 左半部分最大值，也就是左半部比右半部分多出的那一个数。 max ( A [ i - 1 ] , B [ j - 1 ]） 上边的第一个条件我们其实可以合并为 j = ( m + n + 1) / 2 - i，因为如果 m + n 是偶数，由于我们取的是 int 值，所以加 1 也不会影响结果。当然，由于 0 m≤n,im,j=(m+n+1)/2−i≥(m+m+1)/2−i>(m+m+1)/2−m=0m\\leq n,i(m+m+1)/2-m=0m≤n,im,j=(m+n+1)/2−i≥(m+m+1)/2−i>(m+m+1)/2−m=0 m≤n,i>0,j=(m+n+1)/2−i≤(n+n+1)/2−i(n+n+1)/2=nm\\leq n,i>0,j=(m+n+1)/2-i\\leq (n+n+1)/2-im≤n,i>0,j=(m+n+1)/2−i≤(n+n+1)/2−i(n+n+1)/2=n 最后一步由于是 int 间的运算，所以 1 / 2 = 0。 而对于第二个条件，奇数和偶数的情况是一样的，我们进一步分析。为了保证 max ( A [ i - 1 ] , B [ j - 1 ]）） B [ j - 1 ] > A [ i ]，并且为了不越界，要保证 j != 0，i != m 此时很明显，我们需要增加 i ，为了数量的平衡还要减少 j ，幸运的是 j = ( m + n + 1) / 2 - i，i 增大，j 自然会减少。 A [ i - 1 ] > B [ j ] ，并且为了不越界，要保证 i != 0，j != n 此时和上边的情况相反，我们要减少 i ，增大 j 。 上边两种情况，我们把边界都排除了，需要单独讨论。 当 i = 0 , 或者 j = 0 ，也就是切在了最前边。 此时左半部分当 j = 0 时，最大的值就是 A [ i - 1 ] ；当 i = 0 时 最大的值就是 B [ j - 1] 。右半部分最小值和之前一样。 当 i = m 或者 j = n ，也就是切在了最后边。 此时左半部分最大值和之前一样。右半部分当 j = n 时，最小值就是 A [ i ] ；当 i = m 时，最小值就是B [ j ] 。 所有的思路都理清了，最后一个问题，增加 i 的方式。当然用二分了。初始化 i 为中间的值，然后减半找中间的，减半找中间的，减半找中间的直到答案。 class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; if (m > n) { return findMedianSortedArrays(B,A); // 保证 m A[i]){ // i 需要增大 iMin = i + 1; } else if (i != 0 && j != n && A[i-1] > B[j]) { // i 需要减小 iMax = i - 1; } else { // 达到要求，并且将边界条件列出来单独考虑 int maxLeft = 0; if (i == 0) { maxLeft = B[j-1]; } else if (j == 0) { maxLeft = A[i-1]; } else { maxLeft = Math.max(A[i-1], B[j-1]); } if ( (m + n) % 2 == 1 ) { return maxLeft; } // 奇数的话不需要考虑右半部分 int minRight = 0; if (i == m) { minRight = B[j]; } else if (j == n) { minRight = A[i]; } else { minRight = Math.min(B[j], A[i]); } return (maxLeft + minRight) / 2.0; //如果是偶数的话返回结果 } } return 0.0; } } 时间复杂度：我们对较短的数组进行了二分查找，所以时间复杂度是 O（log（min（m，n）））。 空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O ( 1 ) 。 总结 解法二中体会到了对情况的转换，有时候即使有了思路，代码也不一定写的优雅，需要多锻炼才可以。解法三和解法四充分发挥了二分查找的优势，将时间复杂度降为 log 级别。 "},"leetCode-5-Longest-Palindromic-Substring.html":{"url":"leetCode-5-Longest-Palindromic-Substring.html","title":"5. Longest Palindromic Substring","keywords":"","body":"题目描述（中等难度） 给定一个字符串，输出最长的回文子串。回文串指的是正的读和反的读是一样的字符串，例如 \"aba\"，\"ccbbcc\"。 解法一 暴力破解 暴力求解，列举所有的子串，判断是否为回文串，保存最长的回文串。 public boolean isPalindromic(String s) { int len = s.length(); for (int i = 0; i max) { ans = s.substring(i, j); max = Math.max(max, ans.length()); } } return ans; } 时间复杂度：两层 for 循环 O（n²），for 循环里边判断是否为回文，O（n），所以时间复杂度为 O（n³）。 空间复杂度：O（1），常数个变量。 解法二 最长公共子串 根据回文串的定义，正着和反着读一样，那我们是不是把原来的字符串倒置了，然后找最长的公共子串就可以了。例如，S = \" caba\"，S' = \" abac\"，最长公共子串是 \"aba\"，所以原字符串的最长回文串就是 \"aba\"。 关于求最长公共子串（不是公共子序列），有很多方法，这里用动态规划的方法，可以先阅读下边的链接。 https://blog.csdn.net/u010397369/article/details/38979077 https://www.kancloud.cn/digest/pieces-algorithm/163624 整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话 arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。 当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。 arr [ i ][ j ] 保存的就是公共子串的长度。 public String longestPalindrome(String s) { if (s.equals(\"\")) return \"\"; String origin = s; String reverse = new StringBuffer(s).reverse().toString(); //字符串倒置 int length = s.length(); int[][] arr = new int[length][length]; int maxLen = 0; int maxEnd = 0; for (int i = 0; i maxLen) { maxLen = arr[i][j]; maxEnd = i; //以 i 位置结尾的字符 } } } return s.substring(maxEnd - maxLen + 1, maxEnd + 1); } 再看一个例子，S = \"abc435cba\"，S’ = \"abc534cba\" ，最长公共子串是 \"abc\" 和 \"cba\" ，但很明显这两个字符串都不是回文串。 所以我们求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配。 比如 S = \" caba \"，S' = \" abac \" ，S’ 中 aba 的下标是 0 1 2 ，倒置前是 3 2 1，和 S 中 aba 的下标符合，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。 首先 i ，j 始终指向子串的末尾字符。所以 j 指向的红色的 a 倒置前的下标是 beforeRev = length - 1 - j = 4 - 1 - 2 = 1，对应的是字符串首位的下标，我们还需要加上字符串的长度才是末尾字符的下标，也就是 beforeRev + arr[ i ] [ j ] - 1 = 1 + 3 - 1 = 3，因为 arr[ i ] [ j ] 保存的就是当前子串的长度，也就是图中的数字 3 。此时再和它与 i 比较，如果相等，则说明它是我们要找的回文串。 之前的 S = \"abc435cba\"，S' = \"abc534cba\" ，可以看一下图示，为什么不符合。 当前 j 指向的 c ，倒置前的下标是 beforeRev = length - 1 - j = 9 - 1 - 2 = 6，对应的末尾下标是 beforeRev + arr[ i ] [ j ] - 1 = 6 + 3 - 1 = 8 ，而此时 i = 2 ，所以当前的子串不是回文串。 代码的话，在上边的基础上，保存 maxLen 前判断一下下标匹不匹配就可以了。 public String longestPalindrome(String s) { if (s.equals(\"\")) return \"\"; String origin = s; String reverse = new StringBuffer(s).reverse().toString(); int length = s.length(); int[][] arr = new int[length][length]; int maxLen = 0; int maxEnd = 0; for (int i = 0; i maxLen) { int beforeRev = length - 1 - j; if (beforeRev + arr[i][j] - 1 == i) { //判断下标是否对应 maxLen = arr[i][j]; maxEnd = i; } /*************************************/ } } return s.substring(maxEnd - maxLen + 1, maxEnd + 1); } 时间复杂度：两层循环，O（n²）。 空间复杂度：一个二维数组，O（n²）。 空间复杂度其实可以再优化一下。 我们分析一下循环，i = 0 ，j = 0，1，2 ... 8 更新一列，然后 i = 1 ，再更新一列，而更新的时候我们其实只需要上一列的信息，更新第 3 列的时候，第 1 列的信息是没有用的。所以我们只需要一个一维数组就可以了。但是更新 arr [ i ] 的时候我们需要 arr [ i - 1 ] 的信息，假设 a [ 3 ] = a [ 2 ] + 1，更新 a [ 4 ] 的时候， 我们需要 a [ 3 ] 的信息，但是 a [ 3 ] 在之前已经被更新了，所以 j 不能从 0 到 8 ，应该倒过来，a [ 8 ] = a [ 7 ] + 1，a [ 7 ] = a [ 6 ] + 1 , 这样更新 a [ 8 ] 的时候用 a [ 7 ] ，用完后才去更新 a [ 7 ]，保证了不会出错。 public String longestPalindrome(String s) { if (s.equals(\"\")) return \"\"; String origin = s; String reverse = new StringBuffer(s).reverse().toString(); int length = s.length(); int[] arr = new int[length]; int maxLen = 0; int maxEnd = 0; for (int i = 0; i = 0; j--) { /**************************************************/ if (origin.charAt(i) == reverse.charAt(j)) { if (i == 0 || j == 0) { arr[j] = 1; } else { arr[j] = arr[j - 1] + 1; } /**************修改的地方***************************/ //之前二维数组，每次用的是不同的列，所以不用置 0 。 } else { arr[j] = 0; } /**************************************************/ if (arr[j] > maxLen) { int beforeRev = length - 1 - j; if (beforeRev + arr[j] - 1 == i) { maxLen = arr[j]; maxEnd = i; } } } return s.substring(maxEnd - maxLen + 1, maxEnd + 1); } 时间复杂度：O（n²）。 空间复杂度：降为 O（n）。 解法三 暴力破解优化 解法一的暴力解法时间复杂度太高，在 leetCode 上并不能 AC 。我们可以考虑，去掉一些暴力解法中重复的判断。我们可以基于下边的发现，进行改进。 首先定义 P（i，j）。 P(i,j)={trues[i,j]是回文串falses[i,j]不是回文串P(i,j)=\\begin{cases}true& \\text{s[i,j]是回文串} \\\\\\\\false& \\text{s[i,j]不是回文串}\\end{cases}P(i,j)=​⎩​⎪​⎨​⎪​⎧​​​true​​false​​​s[i,j]是回文串​s[i,j]不是回文串​​ 接下来 P(i,j)=(P(i+1,j−1)&&S[i]==S[j])P(i,j)=(P(i+1,j-1)\\&\\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j]) 所以如果我们想知道 P（i，j）的情况，不需要调用判断回文串的函数了，只需要知道 P（i + 1，j - 1）的情况就可以了，这样时间复杂度就少了 O（n）。因此我们可以用动态规划的方法，空间换时间，把已经求出的 P（i，j）存储起来。 如果 S[i+1,j−1]S[i+1,j-1]S[i+1,j−1] 是回文串，那么只要 S [ i ] == S [ j ] ，就可以确定 S [ i , j ] 也是回文串了。 求 长度为 1 和长度为 2 的 P ( i , j ) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j]P[i][j]P[i][j] 中 i > j 的情况，比如求 P[1][2]P[1][2]P[1][2] 的话，我们需要知道 P[1+1][2−1]=P[2][1]P[1+1][2-1]=P[2][1]P[1+1][2−1]=P[2][1] ，而 P[2][1]P[2][1]P[2][1] 代表着 S[2,1]S[2,1]S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。 所以我们先初始化长度是 1 的回文串的 P [ i , j ]，这样利用上边提出的公式 P(i,j)=(P(i+1,j−1)&&S[i]==S[j])P(i,j)=(P(i+1,j-1)\\&\\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。 同理，初始化长度是 2 的回文串 P [ i , i + 1 ]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。 public String longestPalindrome(String s) { int length = s.length(); boolean[][] P = new boolean[length][length]; int maxLen = 0; String maxPal = \"\"; for (int len = 1; len = length) //下标已经越界，结束本次循环 break; P[start][end] = (len == 1 || len == 2 || P[start + 1][end - 1]) && s.charAt(start) == s.charAt(end); //长度为 1 和 2 的单独判断下 if (P[start][end] && len > maxLen) { maxPal = s.substring(start, end + 1); } } return maxPal; } 时间复杂度：两层循环，O（n²）。 空间复杂度：用二维数组 P 保存每个子串的情况，O（n²）。 我们分析下每次循环用到的 P（i，j），看一看能不能向解法二一样优化一下空间复杂度。 当我们求长度为 6 和 5 的子串的情况时，其实只用到了 4 ， 3 长度的情况，而长度为 1 和 2 的子串情况其实已经不需要了。但是由于我们并不是用 P 数组的下标进行的循环，暂时没有想到优化的方法。 之后看到了另一种动态规划的思路 https://leetcode.com/problems/longest-palindromic-substring/discuss/2921/Share-my-Java-solution-using-dynamic-programming 。 公式还是这个不变 首先定义 P（i，j）。 P(i,j)={trues[i,j]是回文串falses[i,j]不是回文串P(i,j)=\\begin{cases}true& \\text{s[i,j]是回文串}\\\\\\\\false& \\text{s[i,j]不是回文串}\\end{cases}P(i,j)=​⎩​⎪​⎨​⎪​⎧​​​true​​false​​​s[i,j]是回文串​s[i,j]不是回文串​​ 接下来 P(i,j)=(P(i+1,j−1)&&S[i]==S[j])P(i,j)=(P(i+1,j-1)\\&\\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j]) 递推公式中我们可以看到，我们首先知道了 i +1 才会知道 i ，所以我们只需要倒着遍历就行了。 public String longestPalindrome(String s) { int n = s.length(); String res = \"\"; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i >= 0; i--) { for (int j = i; j res.length()) { res = s.substring(i, j + 1); } } } return res; } 时间复杂度和空间复杂和之前都没有变化，我们来看看可不可以优化空间复杂度。 当求第 i 行的时候我们只需要第 i + 1 行的信息，并且 j 的话需要 j - 1 的信息，所以和之前一样 j 也需要倒叙。 public String longestPalindrome7(String s) { int n = s.length(); String res = \"\"; boolean[] P = new boolean[n]; for (int i = n - 1; i >= 0; i--) { for (int j = n - 1; j >= i; j--) { P[j] = s.charAt(i) == s.charAt(j) && (j - i res.length()) { res = s.substring(i, j + 1); } } } return res; } 时间复杂度：不变，O（n²）。 空间复杂度：降为 O（n ) 。 解法四 扩展中心 我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。 由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n + n - 1 个中心。 public String longestPalindrome(String s) { if (s == null || s.length() end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1); } private int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L >= 0 && R 时间复杂度：O（n²）。 空间复杂度：O（1）。 解法五 Manacher's Algorithm 马拉车算法。 马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 主要参考了下边链接进行讲解。 https://segmentfault.com/a/1190000008484167 https://blog.crimx.com/2017/07/06/manachers-algorithm/ http://ju.outofmemory.cn/entry/130005 https://articles.leetcode.com/longest-palindromic-substring-part-ii/ 首先我们解决下奇数和偶数的问题，在每个字符间插入\"#\"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 \"^\" 和 \"$\"，两个不可能在字符串中出现的字符，这样向解法四那样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 首先我们用一个数组 P 保存从中心扩展的个数，巧合的它也是去掉 \"#\" 的字符串的总长度，可以看下边的图。 用 P 的下标 i 减去 P[i]，再除以 2 ，就是原字符串的开头下标了。 例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第 （5 - 1）位就可以了。 接下来是算法的关键了，它充分利用了回文串的对称性。 我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[i] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。 用 i_mirror 表示当前扩展的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ] 如果是解法四，那就向两边扩展就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ mirror ] = 3，所以 P [ i ] 也等于 3 。 有三种情况将会造成直接赋值为 P [ mirror ] 是不正确的。 超出了 R 当我们要求 P[i] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [i] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T[R+1] 和 T[R+1]关于 i 的对称点就行了，像解法四一样一个个扩展。 P [ mirror ] 遇到了左边界 此时 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 \"#\" == \"#\" ，之后遇到了 \"^\"和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以接着扩展，就像之前一样。 i 等于了 R 此时我们先把 P [ i ] 赋值为 0 ，然后一步一步扩展就行了。 就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。 此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。 public String preProcess(String s) { int n = s.length(); if (n == 0) { return \"^$\"; } String ret = \"^\"; for (int i = 0; i i) { P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R } else { P[i] = 0;// 等于 R 的情况 } // 碰到之前讲的三种情况时候，需要继续扩展 while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) { P[i]++; } // 判断是否需要更新 R if (i + P[i] > R) { C = i; R = i + P[i]; } } // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i = 1; i maxLen) { maxLen = P[i]; centerIndex = i; } } int start = (centerIndex - maxLen) / 2; //最开始讲的 return s.substring(start, start + maxLen); } 时间复杂度：for 循环里边套了一层 while 循环，难道不是 O ( n² )，不！其实是 O（n）。我们想象一下整个过程，首先外层有一个 for 循环，所以每个字符会遍历一次，而当我们扩展的时候，每次都是从 R + 1 开始扩展，之后又会更新 R 。所以一些字符会遍历两次，但此时这些字符变到 R 的左边，所以不会遍历第三次了，因为我们每次从 R 的右边开始扩展。综上，每个字符其实最多遍历 2 次，所以依旧是线性的，当然如果字符串成为 len ，这里的 n 其实是 2 * len + 3 。所以时间复杂度是 O（n）。 空间复杂度：O（n）。 总结 时间复杂度从三次方降到了一次，美妙！这里两次用到了动态规划去求解，初步认识了动态规划，就是将之前求的值保存起来，方便后边的计算，使得一些多余的计算消失了。并且在动态规划中，通过观察数组的利用情况，从而降低了空间复杂度。而 Manacher 算法对回文串对称性的充分利用，不得不让人叹服，自己加油啦！ "},"leetCode-6-ZigZag-Conversion.html":{"url":"leetCode-6-ZigZag-Conversion.html","title":"6. ZigZag Conversion","keywords":"","body":"题目描述（中等难度） 就是给定一个字符串，然后按写竖着的 「z」的方式排列字符，就是下边的样子。 然后按行的方式输出每个字符，第 0 行，第 1 行，第 2 行 .... 解法一 按照写 Z 的过程，遍历每个字符，然后将字符存到对应的行中。用 goningDown 保存当前的遍历方向，如果遍历到两端，就改变方向。 public String convert(String s, int numRows) { if (numRows == 1) return s; List rows = new ArrayList<>(); for (int i = 0; i 时间复杂度：O（n），n 是字符串的长度。 空间复杂度：O（n），保存每个字符需要的空间。 解法二 找出按 Z 形排列后字符的规律，然后直接保存起来。 我们可以看到，图形其实是有周期的，0，1，2 ... 7 总过 8 个，然后就又开始重复相同的路径。周期的计算就是 cycleLen = 2 × numRows - 2 = 2 × 5 - 2 = 8 个。 我们发现第 0 行和最后一行一个周期内有一个字符，所以第一个字符下标是 0 ，第二个字符下标是 0 + cycleLen = 8，第三个字符下标是 8 + cycleLen = 16 。 其他行都是两个字符。 第 1 个字符和第 0 行的规律是一样的。 第 2 个字符其实就是下一个周期的第 0 行的下标减去当前行。什么意思呢？ 我们求一下第 1 行第 1 个周期内的第 2 个字符，下一个周期的第 0 行的下标是 8 ，减去当前行 1 ，就是 7 了。 我们求一下第 1 行第 2 个而周期内的第 2 个字符，下一个周期的第 0 行的下标是 16 ，减去当前行 1 ，就是 15 了。 我们求一下第 2 行第 1 个周期内的第 2 个字符，下一个周期的第 0 行的下标是 8 ，减去当前行 2 ，就是 6 了。 当然期间一定要保证下标小于 n ，防止越界。 可以写代码了。 public String convert(String s, int numRows) { if (numRows == 1) return s; StringBuilder ret = new StringBuilder(); int n = s.length(); int cycleLen = 2 * numRows - 2; for (int i = 0; i 时间复杂度：O（n），虽然是两层循环，但第二次循环每次加的是 cycleLen ，无非是把每个字符遍历了 1 次，所以两层循环内执行的次数肯定是字符串的长度。 空间复杂度：O（n），保存字符串。 总结 这次算是总结起来最轻松的了，这道题有些找规律的意思。解法一顺着排列的方式遍历，解法二直接从答案入口找出下标的规律。 "},"leetCode-7-Reverse-Integer.html":{"url":"leetCode-7-Reverse-Integer.html","title":"7. Reverse Integer","keywords":"","body":"题目描述（简单难度） 很简单，就是输入整数，输出它的倒置。 第一反应就是， 取余得到个位数，然后除以 10 去掉个位数，然后用一个变量保存倒置的数。 public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; rev = rev * 10 + pop; } return rev; } 然后似乎不是那么理想。 为什么呢？倒置过来不应该是 9646324351 吗。其实题目里讲了，int 的范围是 [−231,231−1][-2^{31} ,2^{31}-1][−2​31​​,2​31​​−1] 也就是 [−2147483648,2147483647][-2147483648,2147483647] [−2147483648,2147483647] 。明显 9646324351 超出了范围，造成了溢出。所以我们需要在输出前，判断是否溢出。 问题的关键就是下边的一句了。 rev = rev * 10 + pop; 为了区分两个 rev ，更好的说明，我们引入 temp 。 temp = rev * 10 + pop; rev = temp; 我们对 temp = rev * 10 + pop; 进行讨论。intMAX = 2147483647 , intMin = - 2147483648 。 对于大于 intMax 的讨论，此时 x 一定是正数，pop 也是正数。 如果 rev > intMax / 10 ，那么没的说，此时肯定溢出了。 如果 rev == intMax / 10 = 2147483647 / 10 = 214748364 ，此时 rev * 10 就是 2147483640 如果 pop 大于 7 ，那么就一定溢出了。但是！如果假设 pop 等于 8，那么意味着原数 x 是 8463847412 了，输入的是 int ，而此时是溢出的状态，所以不可能输入，所以意味着 pop 不可能大于 7 ，也就意味着 rev == intMax / 10 时不会造成溢出。 如果 rev 对于小于 intMin 的讨论同理。 public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev > Integer.MAX_VALUE/10 ) return 0; if (rev 时间复杂度：循环多少次呢？数字有多少位，就循环多少次，也就是 log10(x)+1log_{10}(x) + 1log​10​​(x)+1 次，所以时间复杂度是 O（log（x））。 空间复杂度：O（1）。 当然我们可以不用思考那么多，用一种偷懒的方式 AC ，我们直接把 rev 定义成 long ，然后输出前判断 rev 是不是在范围内，不在的话直接输出 0 。 public int reverse(int x) { long rev = 0; while (x != 0) { int pop = x % 10; x /= 10; rev = rev * 10 + pop; } if (rev > Integer.MAX_VALUE || rev 总结 比较简单的一道题，主要是在考判断是不是溢出，又是轻松的一天！ "},"leetCode-8-String-to-Integer.html":{"url":"leetCode-8-String-to-Integer.html","title":"8. String to Integer","keywords":"","body":" 题目描述（中等难度） 总结 题目描述（中等难度） 将一个字符串转为整型。 这道题，难度其实不大，和上道题有很多重合的地方。整体的思路就是遍历字符串，然后依次取出一个字符就可以了。无非是考虑一些特殊情况，还有就是理解题目意思。 经过多次试错，题目的意思是这样的。 从左遍历字符串，可以遇到空格，直到遇到 ' + ' 或者数字或者 ' - ' 就表示要转换的数字开始，如果之后遇到除了数字的其他字符（包括空格）就结束遍历，输出结果，不管后边有没有数字了，例如 \" - 32332ada2323\" 就输出 \"- 32332\"。 如果遇到空格或者 ' + ' 或者数字或者 ' - ' 之前遇到了其他字符，就直接输出 0 ，例如 \" we1332\"。 如果转换的数字超出了 int ，就返回 intMax 或者 intMin。 public int myAtoi(String str) { int sign = 1; int ans = 0, pop = 0; boolean hasSign = false; //代表是否开始转换数字 for (int i = 0; i = '0' && str.charAt(i) Integer.MAX_VALUE / 10 || (ans * sign == Integer.MAX_VALUE / 10 && pop * sign > 7)) return 2147483647; if (ans * sign 时间复杂度：O（n），n 是字符串的长度。 空间复杂度：O（1）。 总结 这道题让自己有点感到莫名其妙，好像没有 get 到出题人的点？？？ "},"leetCode-9-Palindrome-Number.html":{"url":"leetCode-9-Palindrome-Number.html","title":"9. Palindrome Number","keywords":"","body":" 题目描述（简单难度） 解法一 解法二 解法三 总结 题目描述（简单难度） 判断是不是回文数，负数不是回文数。 解法一 把 int 转成字符串，然后判断是否是回文串做就可以了，缺点是需要额外的空间存储字符串，当然题目也告诉了不能这样，所以 pass 。 解法二 在第 7 道题我们写了倒置 int 的算法，这里当然可以用到了，只需要判断倒置前后相不相等就可以了。 记不记得，当倒置后的数字超出 int 的范围时，我们返回的是 0 ，那么它一定不等于原数，此时一定返回 false 了，这正不正确呢？ 我们只需证明，如果倒置后超出 int 的范围，那么它一定不是回文数字就好了。 反证法，我们假设存在这么一个数，倒置后是超出 int 范围的，并且它是回文数字。 int 最大为 2147483647 , 让我们来讨论这个数可能是多少。 有没有可能是最高位大于 2 导致的溢出，比如最高位是 3 ，因为是回文串，所以最低位是 3 ，这就将导致转置前最高位也会是 3 ，所以不可能是这种情况。 有没有可能是第 2 高位大于 1 导致的溢出，此时保持最高位不变，假如第 2 高位是 2，因为是回文串，所以个位是 2，十位是 2 ，同样的会导致倒置前超出了 int 的最大值，所以也不可能是这种情况。 同理，第 3 高位，第 4，第 5，直线左边的都是上述的情况，所以不可能是前边的位数过大。 为了保证这个数是溢出的，前边 5 位必须固定不变了，因为它是回文串，所以直线后的灰色数字就一定是 4 ，而此时不管后边的数字取多少，都不可能是溢出的了。 综上，不存在这样一个数，所以可以安心的写代码了。 public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev > Integer.MAX_VALUE / 10) return 0; if (rev 时间复杂度：和求转置一样，x 有多少位，就循环多少次，所以是 O（log（x）） 。 空间复杂度：O（1）。 解法三 其实，我们只需要将右半部分倒置然后和左半部比较就可以了。比如 1221 ，把 21 转置和 12 比较就行了。 public boolean isPalindrome(int x) { if (x 时间复杂度：循环 x 的总位数的一半次，所以时间复杂度依旧是 O（log（x））。 空间复杂度：O（1），常数个变量。 总结 这几天都比较简单，加油加油加油！。 "},"leetCode-10-Regular-Expression-Matching.html":{"url":"leetCode-10-Regular-Expression-Matching.html","title":"10. Regular Expression Matching","keywords":"","body":" 题目描述（困难难度） 解法一 递归 解法二 动态规划 总 题目描述（困难难度） 一个简单规则的匹配，「点.」代表任意字符，「星号*」 代表前一个字符重复 0 次或任意次。 解法一 递归 假如没有通配符 * ，这道题的难度就会少了很多，我们只需要一个字符，一个字符匹配就行。如果对递归不是很了解，强烈建议看下这篇文章，可以理清一下递归的思路。 我们假设存在这么个函数 isMatch，它将告诉我们 text 和 pattern 是否匹配 boolean isMatch ( String text, String pattern ) ; 递归规模减小 text 和 pattern 匹配，等价于 text 和 patten 的第一个字符匹配并且剩下的字符也匹配，而判断剩下的字符是否匹配，我们就可以调用 isMatch 函数。也就是 (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')&&isMatch(text.substring(1), pattern.substring(1)); 递归出口 随着规模的减小， 当 pattern 为空时，如果 text 也为空，就返回 True，不然的话就返回 False 。 if (pattern.isEmpty()) return text.isEmpty(); 综上，我们的代码是 public boolean isMatch(String text, String pattern) { if (pattern.isEmpty()) return text.isEmpty(); //判断 text 是否为空，防止越界，如果 text 为空， 表达式直接判为 false, text.charAt(0)就不会执行了 boolean first_match = (!text.isEmpty() && (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')); return first_match && isMatch(text.substring(1), pattern.substring(1)); } 当我们考虑了 * 呢，对于递归规模的减小，会增加对于 * 的判断，直接看代码吧。 public boolean isMatch(String text, String pattern) { if (pattern.isEmpty()) return text.isEmpty(); boolean first_match = (!text.isEmpty() && (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')); //只有长度大于 2 的时候，才考虑 * if (pattern.length() >= 2 && pattern.charAt(1) == '*'){ //两种情况 //pattern 直接跳过两个字符。表示 * 前边的字符出现 0 次 //pattern 不变，例如 text = aa ，pattern = a*，第一个 a 匹配，然后 text 的第二个 a 接着和 pattern 的第一个 a 进行匹配。表示 * 用前一个字符替代。 return (isMatch(text, pattern.substring(2)) || (first_match && isMatch(text.substring(1), pattern))); } else { return first_match && isMatch(text.substring(1), pattern.substring(1)); } } 时间复杂度：有点儿小复杂，待更。 空间复杂度：有点儿小复杂，待更。 解法二 动态规划 上边的递归，为了方便理解，简化下思路。 为了判断 text [ 0，len ] 的情况，需要知道 text [ 1，len ] 为了判断 text [ 1，len ] 的情况，需要知道 text [ 2，len ] 为了判断 text [ 2，len ] 的情况，需要知道 text [ 3，len ] ... 为了判断 text [ len - 1，len ] 的情况，需要知道 text [ len，len ] text [ len，len ] 肯定好求 求出 text [ len，len ] 的情况，就知道了 text [ len - 1，len ] 求出 text [ len - 1，len ] 的情况，就知道了 text [ len - 2，len ] ... 求出 text [ 2，len ] 的情况，就知道了 text [1，len ] 求出 text [ l1，len ] 的情况，就知道了 text [ 0，len ] 从而知道了 text [ 0，len ] 的情况，求得问题的解。 上边就是先压栈，然后出栈，其实我们可以直接倒过来求，可以省略压栈的过程。 我们先求 text [ len，len ] 的情况 利用 text [ len，len ] 的情况 ，再求 text [ len - 1，len ] 的情况 ... 利用 text [ 2，len ] 的情况 ，再求 text [ 1，len ] 的情况 利用 text [1，len ] 的情况 ，再求 text [ 0，len ] 的情况 从而求出问题的解 我们用 dp[i][j]dp[i][j]dp[i][j]表示 text 从 i 开始到最后，pattern 从 j 开始到最后，此时 text 和 pattern 是否匹配。 dp[2][2]dp[2][2]dp[2][2]就是图中橙色的部分. public boolean isMatch(String text, String pattern) { // 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况， // 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了 boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1]; // dp[len][len] 代表两个空串是否匹配了，\"\" 和 \"\" ，当然是 true 了。 dp[text.length()][pattern.length()] = true; // 从 len 开始减少 for (int i = text.length(); i >= 0; i--) { for (int j = pattern.length(); j >= 0; j--) { // dp[text.length()][pattern.length()] 已经进行了初始化 if(i==text.length()&&j==pattern.length()) continue; boolean first_match = (i 时间复杂度：假设 text 的长度是 T，pattern 的长度是 P ，空间复杂度就是 O（TP）。 空间复杂度：申请了 dp 空间，所以是 O（TP），因为每次循环我们只需要知道 i 和 i + 1 时候的情况，所以我们可以向 第 5 题 一样进行优化。 public boolean isMatch(String text, String pattern) { // 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况， // 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了 boolean[][] dp = new boolean[2][pattern.length() + 1]; dp[text.length()%2][pattern.length()] = true; // 从 len 开始减少 for (int i = text.length(); i >= 0; i--) { for (int j = pattern.length(); j >= 0; j--) { if(i==text.length()&&j==pattern.length()) continue; boolean first_match = (i 时间复杂度：不变， O（TP）。 空间复杂度：主要用了两个数组进行轮换，O（P）。 总 这道题对于递归的解法，感觉难在怎么去求时间复杂度，现在还没有什么思路，以后再来补充吧。整体来说，只要理清思路，两种算法还是比较好理解的。 "},"leetCode-11-Container-With-Most-Water.html":{"url":"leetCode-11-Container-With-Most-Water.html","title":"11. Container With Most Water","keywords":"","body":" 题目描述（中等难度） 解法一 暴力解法 解法二 总 题目描述（中等难度） 每个数组代表一个高度，选两个任意的柱子往里边倒水，能最多倒多少水。 解法一 暴力解法 直接遍历任意两根柱子，求出能存水的大小，用一个变量保存最大的。 public int maxArea(int[] height) { int max = 0; for (int i = 0; i max) { max = h * (j - i); } } } return max; } 时间复杂度：O（n²）。 空间复杂度：O（1）。 解法二 我们理一下思路，大小是由长度和高度决定，如果选 0 到 8 就保证了长度最长，此时大小是 0 号柱子的高度 1 乘以长度 8 。我们如果想面积更大怎么做呢，只能减小长度，增加高度。是左边的柱子向右移动变成 1 号柱子呢？还是右边的柱子向左移动变成 7 号柱子呢？当然是哪边的柱子短就改哪边的！只有这样，高度才有可能增加。 例如我们如果把 8 号柱子变成 7 号柱子，此时长度减少了，然而高度还是 0 号柱子没有变化，所以面积就会减少。把 1 号柱子变成 2 号柱子就很好了，因为此时高度就变成了 8 号柱子的高度，面积就有可能会增加。 如果左右两边柱子相等该怎么办呢？随意！ 我们假设 1 号 和 8 号 柱子高度是相等的。如果他们之间的柱子只有 1 根比它俩高或者没有比它俩高的，那么最大面积就一定选取是 1 号和 8 号了，所以 1 号接着变大，或者 8 号接着减小都是无所谓的，因为答案已经确定了。 假设 1 号 和 8 号之间有 2 根或以上的柱子比它俩高，假设是 4 号和 6 号比它俩高。1 号会变到 2 号、3 号，最终为 4 号，8 号会变到 7 号， 6 号，而在这个过程中产生的面积一定不会比 1 号和 8 号产生的面积大，因为过程中的柱子都比 1 号和 8 号低。所以是先变 1 号还是先变 8 号是无所谓的，无非是谁先到达更长的柱子而已。 看一下下边的算法，会更加清楚一些。 public int maxArea2(int[] height) { int maxarea = 0, l = 0, r = height.length - 1; while (l 时间复杂度：O（n）。 空间复杂度：O（1）。 总 为了减少暴力解法的时间复杂度，只能去深层次的理解题意，从而找出突破点。 "},"leetCode-12-Integer-to-Roman.html":{"url":"leetCode-12-Integer-to-Roman.html","title":"12. Integer to Roman","keywords":"","body":" 题目描述（中等难度） 解法一 解法二 解法三 总 题目描述（中等难度） 把数字转换成罗马数字，正常情况就是把每个字母相加，并且大字母在前，小字母在后，上边也介绍了像 4 和 9 那些特殊情况。 解法一 这个是自己的解法，主要思想就是每次取出一位，然后得到相应的罗马数字，然后合起来就行。 public String getRoman(int num,int count){ //count 表示当前的位数，个位，十位... char[]ten={'I','X','C','M'}; //1,10,100,1000 char[]five={'V','L','D'};//5,50,500 String r=\"\"; if(num5&&num 时间复杂度：num 的位数 log10(num)+1log_{10}(num)+1log​10​​(num)+1所以时间复杂度是 O（log（n））。 空间复杂度：常数个变量，O（1）。 下边在分享一些 LeetCode 讨论里的一些解法。 解法二 https://leetcode.com/problems/integer-to-roman/discuss/6310/My-java-solution-easy-to-understand public String intToRoman(int num) { int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}; String[] strs = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"}; StringBuilder sb = new StringBuilder(); for(int i=0;i= values[i]) { num -= values[i]; sb.append(strs[i]); } } return sb.toString(); } 相当简洁了，主要就是把所有的组合列出来，因为罗马数字表示的大小就是把所有字母相加，所以每次 append 那个，再把对应的值减去就行了。 时间复杂度：不是很清楚，也许是 O（1）？因为似乎和问题规模没什么关系了。 空间复杂度：O（1）. 解法三 https://leetcode.com/problems/integer-to-roman/discuss/6376/Simple-JAVA-solution public String intToRoman(int num) { String M[] = {\"\", \"M\", \"MM\", \"MMM\"};//0,1000,2000,3000 String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};//0,100,200,300... String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};//0,10,20,30... String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};//0,1,2,3... return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10]; } 这就更加暴力了，把每位的情况都列出来然后直接返回，但思路清晰明了呀。 时间复杂度：O（1）或者说是 num 的位数，不是很确定。 空间复杂度：O（1）。 总 这道题感觉难度应该是 easy ，没有那么难，就是理清楚题意，然后就可以往出列举就行了。 "},"leetCode-13-Roman-to-Integer.html":{"url":"leetCode-13-Roman-to-Integer.html","title":"13. Roman to Integer","keywords":"","body":" 题目描述（简单难度） 解法一 解法二 解法三 总 题目描述（简单难度） 和上一道题相反，将罗马数字转换成阿拉伯数字。 解法一 先来一种不优雅的，也就是我开始的想法。就是遍历字符串，然后转换就可以，但同时得考虑 IV，IX 那些特殊情况。 public int getInt(char r) { int ans = 0; switch (r) { case 'I': ans = 1; break; case 'V': ans = 5; break; case 'X': ans = 10; break; case 'L': ans = 50; break; case 'C': ans = 100; break; case 'D': ans = 500; break; case 'M': ans = 1000; } return ans; } public int getInt(char r, char r_after) { int ans = 0; switch (r) { case 'I': ans = 1; break; case 'V': ans = 5; break; case 'X': ans = 10; break; case 'L': ans = 50; break; case 'C': ans = 100; break; case 'D': ans = 500; break; case 'M': ans = 1000; break; } if (r == 'I') { switch (r_after) { case 'V': ans = 4; break; case 'X': ans = 9; } } if (r == 'X') { switch (r_after) { case 'L': ans = 40; break; case 'C': ans = 90; } } if (r == 'C') { switch (r_after) { case 'D': ans = 400; break; case 'M': ans = 900; } } return ans; } public boolean isGetTwoInt(char r, char r_after) { if (r == 'I') { switch (r_after) { case 'V': return true; case 'X': return true; } } if (r == 'X') { switch (r_after) { case 'L': return true; case 'C': return true; } } if (r == 'C') { switch (r_after) { case 'D': return true; case 'M': return true; } } return false; } public int romanToInt(String s) { int ans = 0; for (int i = 0; i = 2 && isGetTwoInt(s.charAt(s.length() - 2), s.charAt(s.length() - 1)))) { ans += getInt(s.charAt(s.length() - 1)); } return ans; } 时间复杂度：O（n），n 是字符串的长度。 空间复杂度：O（1）。 下边分享一些优雅的。 解法二 https://leetcode.com/problems/roman-to-integer/description/ public int romanToInt(String s) { int sum=0; if(s.indexOf(\"IV\")!=-1){sum-=2;} if(s.indexOf(\"IX\")!=-1){sum-=2;} if(s.indexOf(\"XL\")!=-1){sum-=20;} if(s.indexOf(\"XC\")!=-1){sum-=20;} if(s.indexOf(\"CD\")!=-1){sum-=200;} if(s.indexOf(\"CM\")!=-1){sum-=200;} char c[]=s.toCharArray(); int count=0; for(;count 把出现的特殊情况，提前减了就可以。 时间复杂度：O（1）。 空间复杂度：O（1）。 解法三 https://leetcode.com/problems/roman-to-integer/discuss/6509/7ms-solution-in-Java.-easy-to-understand 利用到罗马数字的规则，一般情况是表示数字大的字母在前，数字小的字母在后，如果不是这样，就说明出现了特殊情况，此时应该做减法。 private int getVal(char c){ switch (c){ case 'M': return 1000; case 'D': return 500; case 'C': return 100; case 'L': return 50; case 'X' : return 10; case 'V': return 5; case 'I': return 1; } throw new IllegalArgumentException(\"unsupported character\"); } public int romanToInt(String s) { int res = 0; if(s.length() == 0) return res; for (int i = 0; i 时间复杂度：O（1）。 空间复杂度：O（1）。 总 这道题也不难，自己一开始没有充分利用罗马数字的特点，而是用一些 if，switch 语句判断是否是特殊情况，看起来就很繁琐了。 "},"leetCode-14-Longest-Common-Prefix.html":{"url":"leetCode-14-Longest-Common-Prefix.html","title":"14. Longest Common Prefix","keywords":"","body":" 题目描述（简单难度） 解法一 垂直比较 解法二 水平比较 解法三 递归 总 题目描述（简单难度） 解法一 垂直比较 我们把所有字符串垂直排列，然后一列一列的比较，直到某一个字符串到达结尾或者该列字符不完全相同。 下边看一下我的代码，看起来比较多 //这个函数判断 index 列的字符是否完全相同 public boolean isSameAtIndex(String[] strs, int index) { int i = 0; while (i 下边看一下，官方的代码 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; //遍历所有列 for (int i = 0; i 时间复杂度：最坏的情况就是 n 个 长度为 m 的完全一样的字符串，假设 S 是所有字符的和，那么 S = m * n，时间复杂度就是 O（S）。当然正常情况下并不需要比较所有字符串，最多比较 n * minLen 个字符就可以了。 空间复杂度：O（1），常数个额外空间。 解法二 水平比较 我们将字符串水平排列，第 0 个和第 1 个字符串找最长子串，结果为 leet，再把结果和第 2 个字符串比较，结果为 leet，再把结果和第 3 个字符串比较，结果为 lee，即为最终结果。 public String longestCommonPrefix3(String[] strs) { if (strs.length == 0) return \"\"; String prefix = strs[0]; // 保存结果 // 遍历每一个字符串 for (int i = 1; i 时间复杂度：最坏情况和解法一是一样，n 个长度为 m 的完全相同的字符，就要比较所有的字符 S，S = n * m 。但对于正常情况，处于最短字符串前的字符串依旧要比较所有字符，而不是最短字符串个字符，相对于解法一较差。 空间复杂度：O（1）。 解法三 递归 我们把原来的数组分成两部分，求出左半部分的最长公共前缀，求出右半部分的最长公共前缀，然后求出的两个结果再求最长公共前缀，就是最后的结果了。 求左半部分的最长公共前缀，我们可以继续把它分成两部分，按照上边的思路接着求。然后一直分成两部分，递归下去。 直到该部分只有 1 个字符串，那么最长公共子串就是它本身了，直接返回就可以了。 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; return longestCommonPrefix(strs, 0 , strs.length - 1); } //递归不断分成两部分 private String longestCommonPrefix(String[] strs, int l, int r) { if (l == r) { return strs[l]; } else { int mid = (l + r)/2; String lcpLeft = longestCommonPrefix(strs, l , mid); String lcpRight = longestCommonPrefix(strs, mid + 1,r); return commonPrefix(lcpLeft, lcpRight); } } //求两个结果的最长公共前缀 String commonPrefix(String left,String right) { int min = Math.min(left.length(), right.length()); for (int i = 0; i 时间复杂度： 空间复杂度： 每次遇到递归的情况，总是有些理不清楚，先空着吧。 总 进行了垂直比较和水平比较，又用到了递归，solution 里还介绍了二分查找，感觉这里用二分查找有些太僵硬了，反而使得时间复杂度变高了。还介绍了前缀树，这里后边遇到再总结吧。 "},"leetCode-15-3Sum.html":{"url":"leetCode-15-3Sum.html","title":"15. 3Sum","keywords":"","body":" 题目描述（中等难度） 解法一 暴力解法 解法二 总 题目描述（中等难度） 解法一 暴力解法 无脑搜索，三层循环，遍历所有的情况。但需要注意的是，我们需要把重复的情况去除掉，就是 [1, -1 ,0] 和 [0, -1, 1] 是属于同一种情况的。 public List> threeSum(int[] nums) { List> res = new ArrayList>(); for (int i = 0; i temp = new ArrayList(); temp.add(nums[i]); temp.add(nums[j]); temp.add(nums[k]); //判断结果中是否已经有 temp 。 if (isInList(res, temp)) { continue; } res.add(temp); } } } return res; } public boolean isInList(List> l, List a) { for (int i = 0; i a, List b) { int count = 0; Collections.sort(a); Collections.sort(b); //排序后判断每个元素是否对应相等 for (int i = 0; i 时间复杂度：n 表示 num 的个数，三个循环 O（n³），而 isInList 也需要 O（n），总共就是 O(n4)O(n^4)O(n​4​​)，leetCode 复杂度到了 O(n3)O(n^3)O(n​3​​) 一般就报超时错误了，所以算法还得优化。 空间复杂度：最坏情况，即 O（N）, N 是指 n 个元素的排列组合个数，即 N=Cn3N=C^3_nN=C​n​3​​，用来保存结果。 解法二 参考了这里-Java-solution) 主要思想是，遍历数组，用 0 减去当前的数，作为 sum ，然后再找两个数使得和为 sum。 这样看来遍历需要 O（n），再找两个数需要 O（n²）的复杂度，还是需要 O（n³）。 巧妙之处在于怎么找另外两个数。 最最优美的地方就是，首先将给定的 num 排序。 这样我们就可以用两个指针，一个指向头，一个指向尾，去找这两个数字，这样的话，找另外两个数时间复杂度就会从 O（n²），降到 O（n）。 而怎么保证不加入重复的 list 呢？ 要记得我们的 nums 已经有序了，所以只需要找到一组之后，当前指针要移到和当前元素不同的地方。其次在遍历数组的时候，如果和上个数字相同，也要继续后移。文字表述比较困难，可以先看下代码。 public List> threeSum(int[] num) { Arrays.sort(num); //排序 List> res = new LinkedList<>(); for (int i = 0; i 0 && num[i] != num[i-1])) { //两个指针,并且头指针从i + 1开始，防止加入重复的元素 int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo 时间复杂度：O（n²），n 指的是 num 空间复杂度：O（N），最坏情况，即 N 是指 n 个元素的排列组合个数，即 N=Cn3N=C^3_nN=C​n​3​​，用来保存结果。 总 对于遍历，这里用到了从两头同时遍历，从而降低了时间复杂度，很妙！ "},"leetCode-16-3Sum-Closest.html":{"url":"leetCode-16-3Sum-Closest.html","title":"16. 3Sum Closest","keywords":"","body":" 题目描述（中等难度） 解法一 暴力解法 解法二 总 题目描述（中等难度） 和上一道题很类似，只不过这个是给一个目标值，找三个数，使得他们的和最接近目标值。 解法一 暴力解法 遍历所有的情况，然后求出三个数的和，和目标值进行比较，选取差值最小的即可。本以为时间复杂度太大了，神奇的是，竟然 AC 了。 public int threeSumClosest(int[] nums, int target) { int sub = Integer.MAX_VALUE; //保存和 target 的差值 int sum = 0; //保存当前最接近 target 的三个数的和 for (int i = 0; i 时间复杂度：O（n³），三层循环。 空间复杂度：O（1），常数个。 解法二 受到上一题的启发，没有看的，推荐大家可以看一下。我们完全可以先将数组排序，然后先固定一个数字，然后利用头尾两个指针进行遍历，降低一个 O（n）的时间复杂度。 如果 sum 大于 target 就减小右指针，反之，就增加左指针。 public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int sub=Integer.MAX_VALUE; int sum=0; for(int i=0;itarget){ hi--; }else{ lo++; } } } return sum; } 时间复杂度：如果是快速排序的 O(logn)O(log_n)O(log​n​​) 再加上 O（n²），所以就是 O（n²）。 空间复杂度：O（1）。 总 和上一道题非常非常的相似了，先对数组排序，然后利用两头的指针，可以说是十分的优雅了。 "},"leetCode-17-Letter-Combinations-of-a-Phone-Number.html":{"url":"leetCode-17-Letter-Combinations-of-a-Phone-Number.html","title":"17. Letter Combinations of a Phone Number","keywords":"","body":" 题目描述（中等难度） 解法一 定义相乘 解法二 队列迭代 解法三 递归 总 题目描述（中等难度） 给一串数字，每个数可以代表数字键下的几个字母，返回这些数字下的字母的所有组成可能。 解法一 定义相乘 自己想了用迭代，用递归，都理不清楚，灵机一动，想出了这个算法。 把字符串 \"23\" 看成 [\"a\",\"b\",c] * [\"d\",\"e\",\"f\"] ，而相乘就用两个 for 循环实现即可，看代码应该就明白了。 public List letterCombinations(String digits) { List ans = new ArrayList(); for (int i = 0; i getList(int digit) { String digitLetter[] = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; List ans = new ArrayList(); for (int i = 0; i mul(List l1, List l2) { if (l1.size() != 0 && l2.size() == 0) { return l1; } if (l1.size() == 0 && l2.size() != 0) { return l2; } List ans = new ArrayList(); for (int i = 0; i 解法二 队列迭代 参考这里，果然有人用迭代写了出来。主要用到了队列。 public List letterCombinations(String digits) { LinkedList ans = new LinkedList(); if(digits.isEmpty()) return ans; String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; ans.add(\"\"); for(int i =0; i 假如是 \"23\" ，那么 第 1 次 for 循环结束后变为 a, b, c； 第 2 次 for 循环的第 1 次 while 循环 a 出队，分别加上 d e f 然后入队，就变成 b c ad ae af 第 2 次 for 循环的第 2 次 while 循环 b 出队，分别加上 d e f 然后入队，就变成 c ad ae af bd be bf 第 2 次 for 循环的第 3 次 while 循环 c 出队，分别加上 d e f 然后入队，就变成 ad ae af bd be bf cd ce cf 这样的话队列的元素长度再也没有等于 1 的了就出了 while 循环。 解法三 递归 参考这里 private static final String[] KEYS = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; public List letterCombinations(String digits) { if(digits.equals(\"\")) { return new ArrayList(); } List ret = new LinkedList(); combination(\"\", digits, 0, ret); return ret; } private void combination(String prefix, String digits, int offset, List ret) { //offset 代表在加哪个数字 if (offset == digits.length()) { ret.add(prefix); return; } String letters = KEYS[(digits.charAt(offset) - '0')]; for (int i = 0; i 从 a 开始 ，然后递归到 d ，然后 g ，就把 adg 加入，然后再加入 adh，再加入 adi ... 从左到右，递归到底之后就将其加入。 总 这种题的时间复杂度和空间复杂度自己理的不太清楚就没有写了。 "},"leetCode-18-4Sum.html":{"url":"leetCode-18-4Sum.html","title":"18. 4Sum","keywords":"","body":" 题目描述（中等难度） 总 题目描述（中等难度） 和3Sum类似，只不过是找四个数，使得和为 target，并且不能有重复的序列。 如果之前没有做过3Sum可以先看看，自己在上边的基础上加了一个循环而已。 public List> fourSum(int[] num, int target) { Arrays.sort(num); List> res = new LinkedList<>(); //多加了层循环 for (int j = 0; j 0 && num[j] != num[j - 1])) for (int i = j + 1; i 时间复杂度：O（n³）。 空间复杂度：O（N），最坏情况，即 N 是指 n 个元素的排列组合个数，即 N=Cn4N=C^4_nN=C​n​4​​，用来保存结果。 总 完全是按照 3Sum 的思路写的，比较好理解。 "},"leetCode-19-Remov-Nth-Node-From-End-of-List.html":{"url":"leetCode-19-Remov-Nth-Node-From-End-of-List.html","title":"19. Remove Nth Node From End of List","keywords":"","body":" 题目描述（中等难度） 解法一 解法二 遍历一次链表 解法三 总 题目描述（中等难度） 给定一个链表，将倒数第 n 个结点删除。 解法一 删除一个结点，无非是遍历链表找到那个结点前边的结点，然后改变下指向就好了。但由于它是链表，它的长度我们并不知道，我们得先遍历一遍得到它的长度，之后用长度减去 n 就是要删除的结点的位置，然后遍历到结点的前一个位置就好了。 public ListNode removeNthFromEnd(ListNode head, int n) { int len = 0; ListNode h = head; while (h != null) { h = h.next; len++; } //长度等于 1 ，再删除一个结点就为 null 了 if (len == 1) { return null; } int rm_node_index = len - n; //如果删除的是头结点 if (rm_node_index == 0) { return head.next; } //找到被删除结点的前一个结点 h = head; for (int i = 0; i 时间复杂度：假设链表长度是 L ，那么就第一个循环是 L 次，第二个循环是 L - n 次，总共 2L - n 次，所以时间复杂度就是 O（L）。 空间复杂度：O（1）。 我们看到如果长度等于 1 和删除头结点的时候需要单独判断，其实我们只需要在 head 前边加一个空节点，就可以避免单独判断。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length > 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next; } 解法二 遍历一次链表 上边我们遍历链表进行了两次，我们如何只遍历一次呢。 看了 leetcode 的讲解。 想象一下，两个人进行 100m 赛跑，假设他们的速度相同。开始的时候，第一个人就在第二个人前边 10m ，这样当第一个人跑到终点的时候，第二个人相距第一个人依旧是 10m ，也就是离终点 10m。 对比于链表，我们设定两个指针，先让第一个指针遍历 n 步，然后再让它俩同时开始遍历，这样的话，当第一个指针到头的时候，第二个指针就离第一个指针有 n 的距离，所以第二个指针的位置就刚好是倒数第 n 个结点。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; //第一个指针先移动 n 步 for (int i = 1; i 时间复杂度： 第一个指针从 0 到 n ，然后「第一个指针再从 n 到结束」和「第二个指针从 0 到倒数第 n 个结点的位置」同时进行。 而解法一无非是先从 0 到 结束，然后从 0 到倒数第 n 个结点的位置。 所以其实它们语句执行的次数其实是一样的，从 0 到倒数第 n 个结点的位置都被遍历了 2 次，所以总共也是 2L - n 次。只不过这个解法把解法一的两次循环合并了一下，使得第二个指针看起来是顺便遍历，想法很 nice。 所以本质上，它们其实是一样的，时间复杂度依旧是 O（n）。 空间复杂度：O（1）。 解法三 没看讲解前，和室友讨论下，如何只遍历一次链表。室友给出了一个我竟然无法反驳的观点，哈哈哈哈。 第一次遍历链表确定长度的时候，顺便把每个结点存到数组里，这样找结点的时候就不需要再遍历一次了，空间换时间？？？哈哈哈哈哈哈哈哈哈。 public ListNode removeNthFromEnd(ListNode head, int n) { List l = new ArrayList(); ListNode h = head; int len = 0; while (h != null) { l.add(h); h = h.next; len++; } if (len == 1) { return null; } int remove = len - n; if (remove == 0) { return head.next; } //直接得到，不需要再遍历了 ListNode r = l.get(remove - 1); r.next = r.next.next; return head; } 时间复杂度：O（L）。 空间复杂度：O（L）。 总 利用两个指针先固定间隔，然后同时遍历，真的是很妙！另外室友的想法也很棒，哈哈哈哈哈。 "},"leetCode-20-Valid Parentheses.html":{"url":"leetCode-20-Valid Parentheses.html","title":"20. Valid Parentheses","keywords":"","body":" 题目描述（简单难度） 总 题目描述（简单难度） 括号匹配问题。 如果只有一种括号，我们完全可以用一个计数器 count ，遍历整个字符串，遇到左括号加 1 ，遇到右括号减 1，遍历结束后，如果 count 等于 0 ，则表示全部匹配。但如果有多种括号，像 ( [ ) ] 这种情况它依旧会得到 0，所以我们需要用其他的方法。 栈！ 遍历整个字符串，遇到左括号就入栈，然后遇到和栈顶对应的右括号就出栈，遍历结束后，如果栈为空，就表示全部匹配。 public boolean isValid(String s) { Stack brackets = new Stack(); for(int i = 0;i 时间复杂度：O（n）。 空间复杂度：O（n）。 总 如果学过数据结构，一定写过计算器，括号匹配问题一定遇到过的。 "},"leetCode-21-Merge-Two-Sorted-Lists.html":{"url":"leetCode-21-Merge-Two-Sorted-Lists.html","title":"21. Merge Two Sorted Lists","keywords":"","body":" 题目描述（简单难度） 解法一 迭代 解法二 递归 总 题目描述（简单难度） 合并两个有序链表。 解法一 迭代 遍历两个链表。 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode h = new ListNode(0); ListNode ans=h; while (l1 != null && l2 != null) { if (l1.val 时间复杂度：O（m + n）。 空间复杂度：O（1）。 解法二 递归 参考这里 ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val 时间复杂度： 空间复杂度： 总 递归看起来，两个字，优雅！但是关于递归的时间复杂度，空间复杂度的求法，先留个坑吧。 "},"leetCode-22-Generate-Parentheses.html":{"url":"leetCode-22-Generate-Parentheses.html","title":"22. Generate Parentheses","keywords":"","body":" 解法一 暴力破解 解法二 解法三 扩展 卡塔兰数 总题目描述（中等难度） 给一个数字 n ，返回所有合法的括号匹配，刚好和20题相反。 自己没想出来，全部参考 LeetCode 给出的 Solution。 解法一 暴力破解 列举所有的情况，每一位有左括号和右括号两种情况，总共 2n 位，所以总共 22n2^{2n}2​2n​​ 种情况。 public List generateParenthesis(int n) { List combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; } public void generateAll(char[] current, int pos, List result) { if (pos == current.length) { if (valid(current)) result.add(new String(current)); } else { current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); } } public boolean valid(char[] current) { int balance = 0; for (char c: current) { if (c == '(') balance++; else balance--; if (balance 时间复杂度：对每种情况判断是否合法需要 O（n），所以时间复杂度是 O(22nn)O(2^{2n}n)O(2​2n​​n) 。 空间复杂度：O(22nn)O(2^{2n}n)O(2​2n​​n)，乘以 n 是因为每个串的长度是 2n。此外这是假设所有情况都符合的时候，但其实不可能都符合，后边会给出更精确的情况。 解法二 解法一中，我们不停的加左括号，其实如果左括号超过 n 的时候，它肯定不是合法序列了。因为合法序列一定是 n 个左括号和 n 个右括号。 还有一种情况就是如果添加括号的过程中，如果右括号的总数量大于左括号的总数量了，后边不论再添加什么，它都不可能是合法序列了。因为每个右括号必须和之前的某个左括号匹配，如果右括号数量多于左括号，那么一定有一个右括号没有与之匹配的左括号，后边不论加多少左括号都没有用了。例如 n = 3 ，总共会有 6 个括号，我们加到 ( ) ) 3 个括号的情况的时候，有 1 个左括号，2 个右括号，此时后边 3 个括号无论是什么，已经注定它不会是合法序列了。 基于上边的两点，我们只要避免它们，就可以保证我们生成的括号一定是合法的了。 public List generateParenthesis(int n) { List ans = new ArrayList(); backtrack(ans, \"\", 0, 0, n); return ans; } public void backtrack(List ans, String cur, int left, int right, int n){ if (cur.length() == n * 2) { ans.add(cur); return; } //左括号不要超过 n if (left 时间复杂度： 空间复杂度： 递归的复杂度分析，继续留坑 =.=。 解法三 解法二中是用列举的方法，仔细想想，我们每次用递归的时候，都是把大问题换成小问题然后去解决，这道题有没有这个思路呢？ 我们想一下之前的列举过程，第 0 个位置一定会是左括号，然后接着添加左括号或右括号，过程中左括号数一定大于或等于右括号数，当第一次出现左括号数等于右括号数的时候，假如此时的位置是 c 。那么位置 1 到 c - 1 之间一定是合法序列，此外 c + 1 到最后的 2n -1 也是合法序列。而假设总共是 n 组括号，1 到 c - 1 是 a 组括号， c + 1 到 2n - 1 之间则是 n - 1 - a 组括号，如下图 最重要的是，每一个合法序列都会有这么一个数 c ，且唯一。所以我们如果要求 n 组括号的所有序列，只需要知道 a 组括号以及 ( n - a - 1) 组括号的所有序列，然后两两组合即可。 以 n = 3 为例，我们把 0 到 c 之间的括号数记为 a 组， c + 1 到最后的括号数记为 b 组，则 a = 0，b = 2 对应 （）（（））以及 （）（）（） 两种情况，此时 c = 1。 a = 1，b = 1，对应 （（））（（）） 一种情况，此时 c = 3。 a = 2，b = 0 对应 （（（）））， （（）（）） 两种情况，此时 c = 5。 所以我们如果要想求 n 组括号，只需要知道 a 组和 b 组的情况，然后组合起来就可以了。 看起来我们在迭代 a ，其实本质上是在迭代 c ，c = 2a + 1，迭代 a 从 0 到 n - 1 ，就是迭代 c 从 1 到 2n - 1。看起来 c 都是奇数，其实是可以理解的，因为 0 到 c 间都是一组组的括号， 所以 c 一定是奇数。为什么可以迭代 c ，因为上边说到每一个合法序列都对应着一个 c ，遍历 c 的话，就能得到所有的情况了，看一下代码吧。 public List generateParenthesis(int n) { List ans = new ArrayList(); if (n == 0) { ans.add(\"\"); } else { for (int a = 0; a 时间复杂度： 空间复杂度： 留坑。 扩展 卡塔兰数 如果这道题不是让你列举所有的情况， 而是仅仅让你输出 n 对应下有多少种合法序列，该怎么做呢？ 答案就是 1n+1C2nn\\frac{1}{n+1}C^n_{2n}​n+1​​1​​C​2n​n​​，也可以写成1n+1(2nn)\\frac{1}{n+1}\\binom{2n}{n}​n+1​​1​​(​n​2n​​)。怎么证明呢？我主要参考了这里，说一下。 我们假设不考虑是不是合法序列，那么就一共有C2nnC^n_{2n}C​2n​n​​种情况，然后我们只需要把里边的非法情况减去就可以了，一共有多少种非法情况呢？ 首先我们用C2nnC^n_{2n}C​2n​n​​就保证了一定是有 n 个左括号，n 个右括号，那么为什么出现了非法序列？ 为了方便论述，我们把左括号记为 +1，右括号记为 -1. ps：下边的 和 都是指两个数的和，不是你和我中的和。 我们假设非法序列的集合是 M ，而非法序列就是列举过程中右括号数比左括号数多了，也就是和小于 0 了，变成 -1 了。这种情况一旦出现，后边无论是什么括号都改变不了它是非法序列的命了。我们将第一次和等于 -1 的时候的位置记为 d 。每一个非法序列一定存在这样一个 d 。然后关键的地方到了！ 此时我们把 0 到 d 所有的 -1 变成 1，1 变成 -1，我们将每一个非法序列都这样做，就构成了一个新的集合 N ，并且这个集合 N 一定和 M 中的元素一一对应（ N -> M，在集合 N 中第一次出现和为 1 的位置也就是 d ，把 0 到 d 中所有的 -1 变成 1，1 变成 -1 就回到了 M），从而集合 M 的数量就等于集合 N 的数量。集合 N 的数量是多少呢？ 我们来分析下集合 N 是什么样的，集合 N 对应的集合 M 原来的序列本来是这样的，在 0 到 d 之间和是 -1 ，也就是 -1 比 +1 多一个，d + 1 到最后的和一定是 1（因为 n 个 +1 和 n 个 -1 的和一定是 0 ，由于 0 到 d 和是 -1，后边的和一定是 1），也就意味着 +1 比 -1 多一个。而在集合 N 中，我们把 0 到 d 的 -1 变成了 +1 ，+1 变成了 -1 ，所以也变成了 +1 比 -1 多一个，所以集合 N 总共就是 +1 比 -1 多 2 个的集合，也就是 n + 1 个 +1 和 n - 1 个 -1 。 所以集合 N 就是 2n 个位置中选 n - 1 个位置放 -1，其他位置放 +1，总共就有 C2nn−1C^{n - 1}_{2n}C​2n​n−1​​，所以集合 M 也有 C2nn−1C^{n - 1}_{2n}C​2n​n−1​​种。 所有合法序列就有 C2nn−C2nn−1=1n+1C2nnC^n_{2n}-C^{n-1}_{2n}=\\frac{1}{n+1}C^n_{2n}C​2n​n​​−C​2n​n−1​​=​n+1​​1​​C​2n​n​​ 。 将集合 M 和集合 N 建立了一一映射，从而解决了问题，神奇！！！！！！！！！！其实，这个数列就是卡塔兰数，可以看下维基百科的定义。 而这个数列，其实除了括号匹配，还有很多类似的问题，其本质是一样的，例如， 2n 个人排队买票，其中 n 个人持 50 元，n 个人持 100 元。每张票 50 元，且一人只买一张票。初始时售票处没有零钱找零。请问这 2n 个人一共有多少种排队顺序，不至于使售票处找不开钱？ 对于一个无限大的栈，一共n个元素，请问有几种合法的入栈出栈形式？ P = a1 a2 a3 ... an，其中 ai 是矩阵。根据乘法结合律，不改变矩阵的相互顺序，只用括号表示成对的乘积，试问一共有几种括号化方案？ n 个结点可构造多少个不同的二叉树？ ... ... 更多例子可以看维基百科和这里。 而 Solutin 给出的时间复杂度，其实就是卡特兰数。 维基百科的给出的性质。 总 本以为这道题挺常规的，然后自己一直卡在解法三的理解上，查来查去，竟然查出了卡塔兰数，虽然似乎和解法三也没什么关系，但又开阔了很多思路。解法三分析出来的迭代方法，以及用映射证明卡塔兰数的求法，棒！ "},"leetCode-23-Merge-k-Sorted-Lists.html":{"url":"leetCode-23-Merge-k-Sorted-Lists.html","title":"23. Merge k Sorted Lists","keywords":"","body":" 解法一 暴力破解 解法二 一列一列比较 解法三 优先队列 解法四 两两合并 解法五 两两合并优化 总题目描述（困难难度） k 个有序链表的合并。 我们用 N 表示链表的总长度，考虑最坏情况，k 个链表的长度相等，都为 n 。 解法一 暴力破解 简单粗暴，遍历所有的链表，将数字存到一个数组里，然后用快速排序，最后再将排序好的数组存到一个链表里。 public ListNode mergeKLists(ListNode[] lists) { List l = new ArrayList(); //存到数组 for (ListNode ln : lists) { while (ln != null) { l.add(ln.val); ln = ln.next; } } //数组排序 Collections.sort(l); //存到链表 ListNode head = new ListNode(0); ListNode h = head; for (int i : l) { ListNode t = new ListNode(i); h.next = t; h = h.next; } h.next = null; return head.next; } 时间复杂度：假设 N 是所有的数字个数，存到数组是 O（N），排序如果是用快速排序就是 O(NlogN)O(Nlog_N)O(Nlog​N​​) ，存到链表是 O（N），所以取个最大的，就是 O(NlogN)O(Nlog_N)O(Nlog​N​​)。 空间复杂度：新建了一个链表，O（N）。 解法二 一列一列比较 我们可以一列一列的比较，将最小的一个存到一个新的链表里。 public ListNode mergeKLists(ListNode[] lists) { int min_index = 0; ListNode head = new ListNode(0); ListNode h = head; while (true) { boolean isBreak = true;//标记是否遍历完所有链表 int min = Integer.MAX_VALUE; for (int i = 0; i 时间复杂度：假设最长的链表长度是 n ，那么 while 循环将循环 n 次。假设链表列表里有 k 个链表，for 循环执行 k 次，所以时间复杂度是 O（kn）。 空间复杂度：N 表示最终链表的长度，则为 O（N）。 其实我们不需要创建一个新链表保存，我们只需要改变得到的最小结点的指向就可以了。 public ListNode mergeKLists(ListNode[] lists) { int min_index = 0; ListNode head = new ListNode(0); ListNode h = head; while (true) { boolean isBreak = true; int min = Integer.MAX_VALUE; for (int i = 0; i 时间复杂度：假设最长的链表长度是 n ，那么 while 循环将循环 n 次。假设链表列表里有 k 个链表，for 循环执行 k 次，所以时间复杂度是 O（kn）。 空间复杂度：O（1）。 解法三 优先队列 解法二中，我们每次都是取出一个最小的，然后加入一个新的， O（1）的复杂度，再找最小的，O（k） 的复杂度。我们完全可以用一个优先队列。 我们将优先级定义为数越小优先级越高，如果用堆实现优先队列，这样我们每次找最小不再需要 O（k），而是 O（log（k）），当然这样的话，我们加入新的话不再是 O（1），也需要 O（log（k））。可以看看这里和这里。 public ListNode mergeKLists(ListNode[] lists) { //定义优先队列的比较器 Comparator cmp; cmp = new Comparator() { @Override public int compare(ListNode o1, ListNode o2) { // TODO Auto-generated method stub return o1.val-o2.val; } }; //建立队列 Queue q = new PriorityQueue(cmp); for(ListNode l : lists){ if(l!=null){ q.add(l); } } ListNode head = new ListNode(0); ListNode point = head; while(!q.isEmpty()){ //出队列 point.next = q.poll(); point = point.next; //判断当前链表是否为空，不为空就将新元素入队 ListNode next = point.next; if(next!=null){ q.add(next); } } return head.next; } 时间复杂度：while 循环依旧取决于最长的链表长度 n，while 循环里边，如果有 k 个链表，入队出队都需要 log（k），除此之外还有初始化队列的时间复杂度 O（k）。所以时间复杂度是 O（min（k，nlog（k）））。 空间复杂度：优先队列需要 O（k）的复杂度。 解法四 两两合并 利用之前合并两个链表的算法，我们直接两两合并，第 0 个和第 1 个链表合并，新生成的再和第 2 个链表合并，新生成的再和第 3 个链表合并...直到全部合并完。 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode h = new ListNode(0); ListNode ans=h; while (l1 != null && l2 != null) { if (l1.val 时间复杂度：不妨假设是 k 个链表并且长度相同，链表总长度为 N，那么第一次合并就是 N/k 和 N/k ，第二次合并就是 2 * N/k 和 N/k，第三次合并就是 3 * N/k 和 N / k，总共进行 n - 1 次合并，每次合并的时间复杂度是 O（n），所以总时间复杂度就是O(∑i=1k−1(i∗Nk+Nk))=O(kN)O(\\sum_{i=1}^{k-1}(i*\\frac{N}{k}+\\frac{N}{k}))=O(kN)O(∑​i=1​k−1​​(i∗​k​​N​​+​k​​N​​))=O(kN)，可以将两项分开，N/k 其实是常数，分开的第一项是等差数列。 空间复杂度：O（1）。 解法五 两两合并优化 依旧假设是 k 个链表，合并的过程优化下，使得只需要合并 log（k）次。 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode h = new ListNode(0); ListNode ans=h; while (l1 != null && l2 != null) { if (l1.val 时间复杂度：假设每个链表的长度都是 n ，那么时间复杂度就是O(∑i=1log2kn)=O(nlogk)O(\\sum_{i=1}^{log_2k}n)=O(nlogk)O(∑​i=1​log​2​​k​​n)=O(nlogk)。 空间复杂度：O（1）。 总 优先队列的运用印象深刻，此外对两两链表的合并，我们仅仅改变了合并的方式就将时间复杂度降低了很多，美妙！ "},"leetCode-24-Swap-Nodes-in-Pairs.html":{"url":"leetCode-24-Swap-Nodes-in-Pairs.html","title":"24. Swap Nodes in Pairs","keywords":"","body":" 题目描述（中等难度） 解法一 迭代 解法二 递归 总 题目描述（中等难度） 给定一个链表，然后两两交换链表的位置。 解法一 迭代 首先为了避免单独讨论头结点的情况，一般先申请一个空结点指向头结点，然后再用一个指针来遍历整个链表。 先来看一下图示： point 是两个要交换结点前边的一个位置。 public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode point = dummy; while (point.next != null && point.next.next != null) { ListNode swap1 = point.next; ListNode swap2 = point.next.next; point.next = swap2; swap1.next = swap2.next; swap2.next = swap1; point = swap1; } return dummy.next; } 时间复杂度：O（n）。 空间复杂度：O（1）。 解法二 递归 参考这里。 自己画了个参考图。 public ListNode swapPairs(ListNode head) { if ((head == null)||(head.next == null)) return head; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n; } 递归时间复杂度留坑。 总 自己开始没有想出递归的算法，每次都会被递归的简洁吸引。另外，感觉链表的一些题，只要画图打打草稿，搞清指向关系，一般不难。 "},"leetCode-25-Reverse-Nodes-in-k-Group.html":{"url":"leetCode-25-Reverse-Nodes-in-k-Group.html","title":"25. Reverse Nodes in k-Group","keywords":"","body":" 题目描述（困难难度） 解法一 迭代 解法二递归 总 题目描述（困难难度） 将一个链表，每 k 个倒置，最后一组不足 k 个就不倒置。 解法一 迭代 关于单链表倒置，我们在第 2 题就讨论过。有了单链表倒置，这道题无非就是用一个循环，每次将 k 个结点取下来，倒置后再接回去，然后再取 k 个，以此循环，到了最后一组如果不足 k 个，不做处理，直接返回头结点就可以了。所以关键就是，指针指来指去，大家不晕掉就好，我做了图示，大家参考一下。 为了将头结点也一般化，我们创建一个 dummy 结点，然后整个过程主要运用三个指针， tail 指针表示已经倒置后的链表的尾部，subhead 指针表示要进行倒置的子链表，toNull 指针为了将子链表从原来链表中取下来。 一个 while 循环，让 toNull 指针走 k - 1 步使其指向子链表的尾部。中间的 if 语句就是判断当前节点数够不够 k 个了，不够的话直接返回结果就可以了。 将子链表指向 null ，脱离出来。并且用 temp 保存下一个结点的位置。 然后调用倒置函数，将子链表倒置。 接下来四步分别是，新链表接到 tail（注意下边的图 tail 是更新后的位置，之前 tail 在 dummy 的位置） 的后边；更新 tail 到新链表的尾部，也就是之前的 subhead （下图 subhead 也是更新后的位置，之前的位置参见上边的图）；sub_head 更新到 temp 的位置；toNull 到 sub_head 的位置；然后将新的尾部 tail 把之前断开的链表连起来，接到 sub_head 上。 整理下其实就是下边的样子 和初始的时候（下边的图）对比一下，发现 tail，subhead 和 toNull 三个指针已经就位，可以愉快的重复上边的步骤了。 看下代码吧。 public ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; ListNode sub_head = head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode tail = dummy; ListNode toNull = head; while (sub_head != null) { int i = k; //找到子链表的尾部 while (i - 1 > 0) { toNull = toNull.next; if (toNull == null) { return dummy.next; } i--; } ListNode temp = toNull.next; //将子链表断开 toNull.next = null; ListNode new_sub_head = reverse(sub_head); //将倒置后的链表接到 tail 后边 tail.next = new_sub_head; //更新 tail tail = sub_head; //sub_head 由于倒置其实是新链表的尾部 sub_head = temp; toNull = sub_head; //将后边断开的链表接回来 tail.next = sub_head; } return dummy.next; } public ListNode reverse(ListNode head) { ListNode current_head = null; while (head != null) { ListNode next = head.next; head.next = current_head; current_head = head; head = next; } return current_head; } 时间复杂度：while 循环中本质上我们只是将每个结点访问了一次，加上结点倒置访问的一次，所以总共加起来每个结点其实只访问了 2 次。所以时间复杂度是 O（n）。 空间复杂度：O（1）。 解法二递归 有没有被解法一的各种指针绕晕呢，我们有一个更好的选择，递归，这样看起来就会简洁很多。 public ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; ListNode point = head; //找到子链表的尾部 int i = k; while(i - 1 >0){ point = point.next; if (point == null) { return head; } i--; } ListNode temp = point.next; //将子链表断开 point.next = null; //倒置子链表，并接受新的头结点 ListNode new_head = reverse(head); //head 其实是倒置链表的尾部，然后我们将后边的倒置结果接过来就可以了 //temp 是链表断开后的头指针，可以参考解法一的图示 head.next = reverseKGroup(temp,k); return new_head; } public ListNode reverse(ListNode head) { ListNode current_head = null; while (head != null) { ListNode next = head.next; head.next = current_head; current_head = head; head = next; } return current_head; } 复杂度：递归留坑。 总 还是那句话，涉及到链表的，我们就画下图，把各个指针的移动理清楚，一般没啥问题。 "},"leetCode-26-Remove-Duplicates-from-Sorted-Array.html":{"url":"leetCode-26-Remove-Duplicates-from-Sorted-Array.html","title":"26. Remove Duplicates from Sorted Array","keywords":"","body":" 题目描述（简单难度） 我写的 Solution 给出的 总 题目描述（简单难度） 返回非重复数字的个数，并且把 nums 里重复的数字也去掉。 例如，nums = [ 1, 1, 2 ] ，那么就返回 2 ，并且把 nums 变成 [ 1, 2 ]。 这道题，蛮简单的，但是自己写的时候多加了个 while 循环，但和给出的 Solution 本质还是一样的。 我写的 for 循环遍历每个数，while 循环判断当前数和它的后一个数是否相等，相等就后移一个数，并且接着判断后移的数和它后边的数是否相等，然后一直循环下去。不相等就将后一个数保存起来，并且长度加 1，然后结束循环。 public int removeDuplicates(int[] nums) { int len = 1; for (int i = 0; i 时间复杂度： O（n）。 空间复杂度：O（1）。 Solution 给出的 利用快慢指针，i 指针从 0 开始，j 指针从 1 开始，如果 i 和 j 所指数字相等，就一直后移 j 。如果不相等，i 指针后移一位用来保存当前 j 所指的值，然后继续回到 j 的后移中去。 public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; for (int j = 1; j 时间复杂度： O（n）。 空间复杂度：O（1）。 总 不同的思想，决定了写出来的代码不同，但就时间复杂度来看，它们本质还是一样的。 "},"leetCode-27-Remove-Element.html":{"url":"leetCode-27-Remove-Element.html","title":"27. Remove Element","keywords":"","body":" 题目描述（简单难度） 解法一 解法二 总 题目描述（简单难度） 和上一题类似，只不过这个是去除给定的值，看起来还更简单些。 例如给了 nums = [ 3, 2, 2, 3 ]，val = 3， 然后我们返回 len = 2，并且 nums 修改为 [ 2, 2 ] 。 解法一 和上道题一样，我们利用快慢指针，此外我们还得用下反向的思维。快指针 fast 和慢指针 slow，一直移动 fast ，如果 fast 指向的值不等于给定的 val ，我们就将值赋给 slow 指向的位置，slow 后移一位。如果 fast 指向的值等于 val 了，此时 fast 后移一位就可以了，不做其他操作。 public int removeElement(int[] nums, int val) { int fast = 0; int slow = 0; while (fast 时间复杂度：O（n）。 空间复杂度：O（1）。 解法二 参考给出的Soloution。 上边的解法，我们是如果不等于 val 就赋值。但如果按题目的想法，应该是如果等于 val 就移除。我们从正方面去想，也就是等于 val 的话，我们怎么体现移除呢？ 题目中有个说明我们没利用到，他告诉我们说 the order of those five elements can be arbitrary，就是说数组的顺序可以随便换，我们怎么充分利用呢？ 我们可以这样，如果当前元素等于 val 了，我们就把它扔掉，然后将最后一个值赋值到当前位置，并且长度减去 1。什么意思呢？ 比如 1 2 2 4 6，如果 val 等于 2 。那么当移动到 2 的时候，等于 val 了。我们就把最后一个位置的 6 赋值过来，长度减去 1 。就变成了 1 6 2 4。完美！达到了移除的效果。然后当又移动到新的 2 的时候，就把最后的 4 拿过来，变成 1 6 4，达到了移除的效果。看下代码吧。 public int removeElement(int[] nums, int val) { int i = 0; int n = nums.length; while (i 时间复杂度：同样是 O（n），但如果等于 val 的值比较少，解法二会更有效率些。比如 1 2 3 4，val = 2。解法一 while 循环中将调用 3 次赋值。而解法二中，仅仅当等于 val 的时候赋值 1 次。 空间复杂度：O（1）。 总 Solution 给出的想法让人耳目一新，对于移除的值少的情况，优化了不少。 "},"leetCode-28-Implement-strStr.html":{"url":"leetCode-28-Implement-strStr.html","title":"28. Implement strStr()","keywords":"","body":" 题目描述（简单难度） 总 题目描述（简单难度） 返回一个字符串 needle 在另一个字符串 haystack 中开始的位置，如果不存在就返回 -1 ，如果 needle 长度是 0 ，就返回 0 。 就是一一比较就好，看下代码吧。 public int strStr(String haystack, String needle) { if (needle.length() == 0) { return 0; } int j = 0; //遍历每个字符 for (int i = 0; i 时间复杂度：假设 haystack 和 needle 的长度分别是 n 和 k，对于每一个 i ，我们最多执行 k - 1 次，总共会有 n 个 i ，所以时间复杂度是 O（kn）。 空间复杂度：O（1）。 我们再看下别人的代码，用两个 for 循环。但本质其实是一样的，但可能会更好理解些吧。 public int strStr(String haystack, String needle) { for (int i = 0; ; i++) { for (int j = 0; ; j++) { if (j == needle.length()) return i; if (i + j == haystack.length()) return -1; if (needle.charAt(j) != haystack.charAt(i + j)) break; } } } 总 总的来说，还是比较简单的，就是简单的遍历就实现了。 "},"leetCode-29-Divide-Two-Integers.html":{"url":"leetCode-29-Divide-Two-Integers.html","title":"29. Divide Two Integers","keywords":"","body":" 题目描述（中等难度） 尝试1 尝试二 尝试三 解法一 解法二 总 题目描述（中等难度） 两个数相除，给出商。不能用乘法，除法和模操作。 本来觉得这道题蛮简单的，记录下自己的坎坷历程。 尝试1 先确定商的符号，然后把被除数和除数通通转为正数，然后用被除数不停的减除数，直到小于除数的时候，用一个计数遍历记录总共减了多少次，即为商了。 确定商的符号的时候，以及返回最终结果的时候，我们可能需要进行乘 -1 操作，即取相反数。而题目规定不让用乘法，所以我们需要知道计算机是怎么进行存数的。 计算机为了算减法，利用了同余的性质。 同余的定义是 a ≡ b ( mod m ) ，即 a mod m == b mod m ，例如 5 ≡ 17 mod ( 12 )。百度百科 同余有两个性质 反身性：a ≡ a ( mod m )； 同余式相加：若 a ≡ b ( mod m )，c ≡ d ( mod m )，则 a + c ≡ b + d ( mod m )； 现在我们进行模 16 的加法操作，先熟悉下下边的几个式子。 2 + 14 = 0 2 + （-3） = 15 5 + 15 = 4 重点来了！ 计算 4 - 2 怎么算呢？ 也就是 4 + （- 2） 4 ≡ 4（mod 16） -2 ≡ 14（mod 16） 所以 4 + （- 2）= 4 + 14 = 2。 我们利用同余的性质，把减法成功转换成了加法，所以我们只需要在计算机里边将 -2 存成 8 就行了。我们这里减去 2 就等价于加上 14。 再比如 13 - 7 ，也就是 13 + （-7） 13 ≡ 13 （mod 16） -7 ≡ 9（mod 16） 所有 13 + （- 7）= 13 + 9 = 6 我们成功把减 7 转换成了加上 9。 减 2 转换成加 14，减 7 转换成加 9，这几组数有什么联系呢？是的 2 + 14 = 16，7 + 9 = 16，他们相加通通等于 16，也就是我们取的模。有种互补的感觉，所以我们把 14 叫做 - 2 的补数，9 叫做 - 7 的补数。 可以看到，我们用一些正数表示了负数，总共有 16 个数，除去 0，还剩 15 个数，不可避免的是，这 16 个数，正数和负数的个数会相差 1，我们来看看是正数多，还是负数多。 补数 0 1 2 3 4 5 6 7 8 所代表的的数 0 1 2 3 4 5 6 7 等下 补数 15 14 13 12 11 10 9 所代表的数 -1 -2 -3 -4 -5 -6 -7 上边的列出的数，应该都没异议吧，那么正数多还是负数多呢？就取决于 8 代表多少了。 8 + 1 = 9 ，9 代表 -7 ，而 - 8 + 1 = - 7，所以 8 其实代表 - 8 。 所以 0 到 15 这 16 个数字可以表示的范围是 -8 ~ 7，-8 没有对称的正数。 我们再来看看计算机里是怎么存的，我们都知道，计算机中是以二进制的方式存储的。假设我们计算机能存储 4 位。范围就是 0000 到 1111，也就是 0 到 15。 补数 0 1 2 3 4 5 6 7 二进制表示 0000 0001 0010 0011 0100 0101 0110 0111 所代表的数 0 1 2 3 4 5 6 7 补数 15 14 13 12 11 10 9 8 二进制表示 1111 1110 1101 1100 1011 1010 1001 1000 所代表的数 -1 -2 -3 -4 -5 -6 -7 -8 我们利用这个表格，求几个例子。 2 - 3 = 2 + （-3）= 2 的补数 + - 3 的补数 = 0010 + 1101 = 1111 而看表格， 1111 代表的数就是 -1 ，从而我们用加法计算出了 2 - 3 = - 1。 -3 - 2 = （-3）+（-2）= -3 的补数 + -2 的补数 = 1101 + 1110 = 1011 我们可以看到 1101 + 1110 本来等于 1 1011 ，因为只存储 4 位，所以最高位被丢掉了，其实这就进行了取模的操作，减去了 16 。如果我们看所对应的十进制是怎么操作的， 1101 表示 13，1110 表示 14 ，13 + 14 = 27 ，如果是模 16 操作下，就是 11 ，而 11 就是上边的结果 1011，看表格它代表的数是 - 5，- 3 - 2 = - 5 ，没毛病。 而且我们发现用这种表示方式，所有的正数首位都是 0 ，负数的首位都是 1 ，这一定不是巧合。按我的理解，因为我们要保证正数和他的相反数相加等于 0000 ，如果首位是相同的，那么该位相加一定会是 0 （0 + 0 = 0，1 + 1 = 0，因为高位被丢掉了），假如 0010 的相反数是 0xxx，为了使得后三位相加等于 0 ，一定得产生进位才能实现（不产生进位，我们无法把 0010 中的 1 变成 0），如果产生了进位，那么首位就变成了 1，它的和就变成了 1000 ，不是 0000，产生矛盾。所以正数和负数的首位一定相反，我们可以把它看做符号位。即首位是 0 就是正数，首位是 1 就是负数。 接下来的问题，给出一个数我们总不能查表去看它的补码吧，我们如何得出补码？ 对于正数，看表格，我们直接写原码就可以了，例如 7 就是 0111 。 负数呢？ 我们之前讨论过，对于模 16 的话，- 2 的补码是 14，也就是 16 - 2。- 7 的补码是 9，也就是 16 - 7 = 9。 我们从二进制的方式看一下。 我们来求 - 2 的补码，用 16 - 2 = 1 0000 - 0010 = ( 1111 + 1 ) - 0010 = ( 1111 - 0010 ) + 1 = 1101 + 1 = 1110 。 为什么转换成 1111 减去一个数，因为用 1111 减去一个数，虽然是减法，但其实只要把这个数按位求反即可。也就是 0010 按位求反变成 1101，再加上 1 就是它的补码了，「按位取反，末位加 1 」这个口诀是不是很熟悉，哈哈，这就是快速求补码的法则。但我们不要忘了它的本质，其实是用模长减去它，但是计算机并不会减法，而是巧妙的转换到了取反再加 1 。 逆过程呢？如果我们知道了计算机存了个数 1110，那么它代表多少呢？首先首位是 1 ，它一定是一个负数，其次它是怎么得来的呢？往上翻，其实是用 16 - 2 =1110 得到的，我们现在是准备求 2 ，用 16 减去它就可以了，也就是 16 - 1110 = 1 0000 - 1110 = （1111 + 1）- 1110 = （1111 - 1110） + 1 = 0010。巧了，依旧是按位取反，末位加 1。而 0010 就是 2，所以 1110 就代表 - 2。 综上，其实我们就是用原来的一部分正数（其实说它是正数也无非是我们自己定义的，想起一句话，数学就像一门宗教，你要么完全相信，要么完全不信，哈哈）表示了负数，而现在为了实现减法，我们把 1xxx 的不当做正数了，把它定义为负数，是的没有负号，但开头是 1 ，我们就说它是负数，再取个名字就叫补数吧（其实就是它代表的负数离它最近的一个和它同余的数，例如 - 3，和它同余的最近的正数就是 13 了，所以 -3 的补数就是 13），再利用余数定理，以及计算机高位溢出等效于求模的性质，巧妙的用取反以及加法实现了减法。 说了这么多，回到开头的部分，怎么不用乘法，来实现求相反数呢？ 求 x 的相反数，我们用 0 减去 x 就行。也就是 x 的相反数 = 0 - x = 0 + ( - x ) = -x，-x 在计算机中怎么存的呢，存的是 -x 的补码，-x 的补码怎么求？把 x 按位取反，末位加 1 。Java 中就是 ~x + 1 了，此时所存的就是 x 对应的那个负数，即它的相反数了。 3 的相反数怎么求？这求什么求呀，添个负号就行了，-3 呀！但是计算机可没我们这么智能，它只存储 01，所以我们把 -3 的补码求出来存到计算机里就可以了。 即把 3 （0011） 按位取反，末位加 1，得到 1101 就是它的补码，我们然后把 1101 存到了计算机中，我们以为它是 13 ，但我们给计算机重新定义了规则，它是补码，首位就代表了它是负数，计算机根据规则（按位取反，末位加 1 ，再添个负号）把它又还原成了我们所理解的 - 3。从而我们不进行乘法，根据我们给计算机制定的规则，实现了求相反数。 public int divide(int dividend, int divisor) { int ans = 0; int sign = 1; if (dividend 0 ? ans : opposite(ans); } public int opposite(int x) { return ~x + 1; } 本来信心满满，结果 Wrong Answer。 为什么出错了？ -1247483648 这个数有什么特殊之处吗？ 我们知道 int 是用 4 个字节存储，也就是 32 位，那它表示的范围是多少呢？有多少个正数呢？除了第 1 位是 0 固定不变，其它位可以取 0 也可以 取 1，所以是 2312^{31}2​31​​，但这样的话还就包括了 0 ，所以还得减去 1 个数。也就是 231−1=21474836472^{31}-1=21474836472​31​​−1=2147483647。那负数有多少个呢，同理除了第 1 位是 1 固定不变，其它位可以取 0 也可以取 1，所以是 231=21474836482^{31}=21474836482​31​​=2147483648 个负数，所以所表示的范围就是 -2147483648 到 2147483647。和之前我们讨论的是一致的，负数比正数多 1 个。 算法中，我们首先对被除数 - 2147483648 取相反数，变成了多少呢？这个不好想，那我们看之前的例子，再模 16 的基础上，最小的负数 - 8 ，取相反数变成了多少，- 8 的补码 1000，按位取反，末位加1，0111 + 1 = 1000，又回到了 1000，所以依旧是 - 8。所以题目中的 - 2147483648 取相反数，依旧是 - 2147483648（有没有发现很神奇 - 2147483648 * - 1 依旧是 - 2147483648）。所以上边的算法中，由于被除数依旧是个负数，所以根本没有进 while 循环，所以直接返回了 0 。 尝试二 既然 - 2147483648 这么特殊，那我们对它单独判断吧，如果被除数是 - 2147483648，除数是 -1 ，我们就直接返回题目所要求的 2147483647 吧，并且如果除数是 1 就返回 - 2147483648。 public int divide(int dividend, int divisor) { int ans = 0; int sign = 1; if (dividend 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } while (divisor 0 ? ans : opposite(ans); } public int opposite(int x) { return ~x + 1; } 接着意外又发生了，这次竟然是 Time Limit Exceeded 了。 尝试三 逛了逛 Discuss，由于我们每次只减 1 次除数，循环太多了，找到了解决方案。 我们每次减 1 次除数，我们其实可以每次减多次。比如 10 / 1 ，之前是 10 - 1 = 9，计数器加 1 变成 1，然后 9 - 1 = 8，计数器加 1 变成 2，然后 8 - 1= 7，计数器加 1 变成 3，直至减到 0 public int divide(int dividend, int divisor) { int ans = 1; int sign = 1; if (dividend 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } int origin_dividend = dividend; int origin_divisor = divisor; //由于 ans 初始值是 1 ，所以如果被除数小于除数直接返回 0 if (dividend 0 ? a : opposite(a); } public int opposite(int x) { return ~x + 1; } 不是超时了，神奇的错误又出现了， 我们又看到了，-2147483648 的出现，当除数是它的时候，又出现了神奇的错误，那我们再单独判断一下除数是它，总该可以了吧，继续加上。 if(divisor == Integer.MIN_VALUE){ return 0; } 其他的错误又出现了 被除数是 -2147483648 ，咦？我们之前不是考虑了吗，不不不，我们只考虑了除数是 1 和 -1 的时候，所以这个问题其实我们一直没有解决。我们必须修改算法了，我们的算法开始的部分是不管三七二十一，通通转换成正数，而出现 -2147483648 的时候，它无法转换成正数，我们怎么该解决呢？ 解法一 虽然感觉很投机取巧，但也是最直接的方法了，既然 int 存不了，那我通通用 long 存就行了吧，最后返回的时候看看是不是 int 不能表示的 2147483648，是的话按题目要求就返回 2147483647。 public int divide(int dividend, int divisor) { long ans = divide((long)dividend,(long)(divisor)); long m = 2147483648L; if(ans == m ){ return Integer.MAX_VALUE; }else{ return (int)ans; } } public long divide(long dividend, long divisor) { long ans = 1; long sign = 1; if (dividend 0 ? a : opposite(a); } public long opposite(long x) { return ~x + 1; } 时间复杂度：最坏的情况，除数是 1，如果一次一次减除数，那么我们将减 n 次，但由于每次都翻倍了，所以总共减了 log ( n ) 次，所以时间复杂度是 O（log （n））。 空间复杂度： O（1）。 解法二 上边的解法总归不够优雅，那么如何不用 long 呢？ 负数比正数多一个，我们之前的思路是把负数变成正数，但由于最小的负数无法变成正数，所以出现了上边奇奇怪怪的问题。我们为什么不把思路转过来，把正数通通转为求负数呢？然后很多加法会变成减法，大于号随之也会变成小于号。 public int divide(int dividend, int divisor) { int ans = -1; int sign = 1; if (dividend > 0) { sign = opposite(sign); dividend = opposite(dividend); } if (divisor > 0) { sign = opposite(sign); divisor = opposite(divisor); } int origin_dividend = dividend; int origin_divisor = divisor; if (dividend > divisor) { return 0; } dividend -= divisor; while (divisor >= dividend) { ans = ans + ans; divisor += divisor; dividend -= divisor; } //此时我们传进的是两个负数，正常情况下，它就返回正数，但我们是在用负数累加，所以要取相反数 int a = ans + opposite(divide(origin_dividend - divisor, origin_divisor)); if(a == Integer.MIN_VALUE){ if( sign > 0){ return Integer.MAX_VALUE; }else{ return Integer.MIN_VALUE; } }else{ if(sign > 0){ return opposite(a); }else{ return a; } } } public int opposite(int x) { return ~x + 1; } } 时间复杂度和空间复杂度没有变化，但是我们优雅的实现了这个算法，没有借用 long 。 总 这道题看起来简单，却藏了不少坑。首先，我们用一次一次减造成了超时，然后我们用递归实现了加倍加倍的减，接着由于 int 表示的数的范围不是对称的，最小的负数并不能转换为对应的相反数，所以我们将之前的算法思路完全逆过来，正数边负数，大于变小于，还是蛮有意思的。 "},"leetCode-30-Substring-with-Concatenation-of-All-Words.html":{"url":"leetCode-30-Substring-with-Concatenation-of-All-Words.html","title":"30. Substring with Concatenation of All Words","keywords":"","body":" 题目描述（困难难度） 解法一 解法二 总 题目描述（困难难度） 给定一个字符串 s ，给定 n 个单词 word，找出所有子串的开始下标，使得子串包含了给定的所有单词，顺序可以不对应。如果有重复的单词，比如有 [ \" foo \" , \" foo \" ] 那么子串也必须含有两个 \" foo \"，也就是说个数必须相同。 解法一 参考 leetCode 里的 solution) 首先，最直接的思路，判断每个子串是否符合，符合就把下标保存起来，最后返回即可。 如上图，利用循环变量 i ，依次后移，判断每个子串是否符合即可。 怎么判断子串是否符合？这也是这个题的难点了，由于子串包含的单词顺序并不需要固定，如果是两个单词 A，B，我们只需要判断子串是否是 AB 或者 BA 即可。如果是三个单词 A，B，C 也还好，只需要判断子串是否是 ABC，或者 ACB，BAC，BCA，CAB，CBA 就可以了，但如果更多单词呢？那就崩溃了。 链接)的作者提出了，用两个 HashMap 来解决。首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。看下具体的例子。 看下图，我们把 words 存到一个 HashMap 中。 然后遍历子串的每个单词。 第一个单词在 HashMap1 中，然后我们把 foo 存到 HashMap2 中。并且比较此时 foo 的 value 和 HashMap1 中 foo 的 value，1 第二个单词也在 HashMap1 中，然后把 foo 存到 HashMap2 中，因为之前已经存过了，所以更新它的 value 为 2 ，然后继续比较此时 foo 的 value 和 HashMap1 中 foo 的 value，2 第三个单词也在 HashMap1 中，然后把 foo 存到 HashMap2 中，因为之前已经存过了，所以更新它的 value 为 3，然后继续比较此时 foo 的 value 和 HashMap1 中 foo 的 value，3 > 2，所以表明该字符串不符合。然后判断下个子串就好了。 当然上边的情况都是单词在 HashMap1 中，如果不在的话就更好说了，不在就表明当前子串肯定不符合了，直接判断下个子串就好了。 看一下代码吧 public List findSubstring(String s, String[] words) { List res = new ArrayList(); int wordNum = words.length; if (wordNum == 0) { return res; } int wordLen = words[0].length(); //HashMap1 存所有单词 HashMap allWords = new HashMap(); for (String w : words) { int value = allWords.getOrDefault(w, 0); allWords.put(w, value + 1); } //遍历所有子串 for (int i = 0; i hasWords = new HashMap(); int num = 0; //判断该子串是否符合 while (num allWords.get(word)) { break; } } else { break; } num++; } //判断是不是所有的单词都符合条件 if (num == wordNum) { res.add(i); } } return res; } 时间复杂度：假设 s 的长度是 n，words 里有 m 个单词，那么时间复杂度就是 O（n * m）。 空间复杂度：两个 HashMap，假设 words 里有 m 个单词，就是 O（m）。 解法二 参考 https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13656/An-O(N)-solution-with-detailed-explanation。 我们在解法一中，每次移动一个字符。 现在为了方便讨论，我们每次移动一个单词的长度，也就是 3 个字符，这样所有的移动被分成了三类。 以上三类我们以第一类从 0 开始移动为例，讲一下如何对算法进行优化，有三种需要优化的情况。 情况一：当子串完全匹配，移动到下一个子串的时候。 在解法一中，对于 i = 3 的子串，我们肯定是从第一个 foo 开始判断。但其实前两个 foo 都不用判断了 ，因为在判断上一个 i = 0 的子串的时候我们已经判断过了。所以解法一中的 HashMap2 每次并不需要清空从 0 开始，而是可以只移除之前 i = 0 子串的第一个单词 bar 即可，然后直接从箭头所指的 foo 开始就可以了。 情况二：当判断过程中，出现不符合的单词。 但判断 i = 0 的子串的时候，出现了 the ，并不在所给的单词中。所以此时 i = 3，i = 6 的子串，我们其实并不需要判断了。我们直接判断 i = 9 的情况就可以了。 情况三：判断过程中，出现的是符合的单词，但是次数超了。 对于 i = 0 的子串，此时判断的 bar 其实是在 words 中的，但是之前已经出现了一次 bar，所以 i = 0 的子串是不符合要求的。此时我们只需要往后移动窗口，i = 3 的子串将 foo 移除，此时子串中一定还是有两个 bar，所以该子串也一定不符合。接着往后移动，当之前的 bar 被移除后，此时 i = 6 的子串，就可以接着按正常的方法判断了。 所以对于出现 i = 0 的子串的情况，我们可以直接从 HashMap2 中依次移除单词，当移除了之前次数超的单词的时候，我们就可以正常判断了，直接从移除了超出了次数的单词后，也就是 i = 6 开始判断就可以了。 看一下代码吧。 public List findSubstring(String s, String[] words) { List res = new ArrayList(); int wordNum = words.length; if (wordNum == 0) { return res; } int wordLen = words[0].length(); HashMap allWords = new HashMap(); for (String w : words) { int value = allWords.getOrDefault(w, 0); allWords.put(w, value + 1); } //将所有移动分成 wordLen 类情况 for (int j = 0; j hasWords = new HashMap(); int num = 0; //记录当前 HashMap2（这里的 hasWords 变量）中有多少个单词 //每次移动一个单词长度 for (int i = j; i allWords.get(word)) { // hasWords.put(word, value); hasRemoved = true; int removeNum = 0; //一直移除单词，直到次数符合了 while (hasWords.get(word) > allWords.get(word)) { String firstWord = s.substring(i + removeNum * wordLen, i + (removeNum + 1) * wordLen); int v = hasWords.get(firstWord); hasWords.put(firstWord, v - 1); removeNum++; } num = num - removeNum + 1; //加 1 是因为我们把当前单词加入到了 HashMap 2 中 i = i + (removeNum - 1) * wordLen; //这里依旧是考虑到了最外层的 for 循环，看情况二的解释 break; } //出现情况二，遇到了不匹配的单词，直接将 i 移动到该单词的后边（但其实这里 //只是移动到了出现问题单词的地方，因为最外层有 for 循环， i 还会移动一个单词 //然后刚好就移动到了单词后边） } else { hasWords.clear(); i = i + num * wordLen; num = 0; break; } num++; } if (num == wordNum) { res.add(i); } //出现情况一，子串完全匹配，我们将上一个子串的第一个单词从 HashMap2 中移除 if (num > 0 && !hasRemoved) { String firstWord = s.substring(i, i + wordLen); int v = hasWords.get(firstWord); hasWords.put(firstWord, v - 1); num = num - 1; } } } return res; } 时间复杂度：算法中外层的两个for 循环的次数肯定是所有的子串，假设是 n。考虑一下，最极端的情况，每个子串的判断都进了 while 循环，wordNum 等于 m。对于解法一，因为每次都是从头判断，所以 while 循环循环了 m 次。但这里我们由于没有清空，所以每次只判断新加入的单词就可以了，只需判断一次，所以时间复杂度是 O（n）。 或者换一种理解方式，判断子串是否符合，本质上也就是判断每个单词符不符合，假设 s 的长度是 n，那么就会大约有 n 个子串，也就是会有 n 个单词。而对于每个单词，我们只有刚开始判断符不符合的时候访问一次，还有就是把它移除的时候访问一次，所以每个单词最多访问 2 次，所以时间复杂度是 O（n）。 空间复杂度：没有变化，依旧是两个 HashMap, 假设 words 里有 m 个单词，就是 O（m）。 总 这道题最大的亮点就是应用了 HashMap 了吧，使得我们不再纠结于子串包含单词的顺序。然后对于算法的优化上，还是老思路，去分析哪些判断是不必要的，然后把它除之。 "},"leetCode-31-Next-Permutation.html":{"url":"leetCode-31-Next-Permutation.html","title":"31. Next Permutation","keywords":"","body":" 题目描述（中等难度） 解法一 总 题目描述（中等难度） 这道题的的难度我觉得理解题意就占了一半。题目的意思是给定一个数，然后将这些数字的位置重新排列，得到一个刚好比原数字大的一种排列。如果没有比原数字大的，就升序输出。 关键就是刚好是什么意思？比如说原数字是 A，然后将原数字的每位重新排列产生了 B C D E，然后把这 5 个数字从小到大排列，比如是 D A B E C ,那么，我们要找的就是 B，就是那个刚好比 A 大的数字。 再比如 123，其他排列有 132，213，231，312，321，从小到大排列就是 123 132 213 231 312 321，那么我们要找的就是 132。 题目还要求空间复杂度必须是 O（1）。 解法一 我们想几个问题。 要想使得数字变大，只要任意一位变大就可以。 要想得到刚好大于原来的数字，要变个位。 这里变大数字，只能利用交换。 如果从个位开始，从右往左进行，找一个比个位大的，交换过来，个位的数字交换到了更高位，由于个位的数字较小，所以交换过去虽然个位变大了，但数字整体变小了。例如 1 3 2，把 2 和 3 交换，变成 1 2 3，个位变大了，但整体数字变小了。 个位不行，我们再看十位，如果从十位左边找一个更大的数字交换过来，和个位的情况是一样的，数字会变小。例如 4 1 2 3，把 2 和 4 交换，2 1 4 3，数字会变小。如果从右边找一个更大的数字交换过来，由于是从低位交换过来的，所以数字满足了会变大。如 4 1 2 3，把 2 和 3 交换，变成 4 1 3 2 数字变大了。 如果十位右边没有比十位数字大的，我们就左移看下一位，再看当前位右边，有没有更大的数字，没有就一直左移就可以。 还有一个问题，如果右边有不止一个大于当前位的数字选哪个？选那个刚好大于当前位的，这样会保证数字整体尽可能的小。 交换完结束了吗？并没有。因为交换完数字变大了，但并不一定是刚好大于原数字的。例如 158476531，我们从十位开始，十位右边没有大于 3 的。再看百位，百位右边没有大于 5 的。直到 4 ，右边出现了很多大于 4 的，选那个刚好大于 4 的，也就是 5 。然后交换，变成 158576431，数字变大了，但并不是刚好大于 158476531，我们还需要将 5 右边的数字从小到大排列。变成158513467，就可以结束了。 而最后的排序，我们其实并不需要用排序函数，因为交换的位置也就是 5 的右边的数字一定是降序的，我们只需要倒序即可了。看一下 LeetCode 提供的动图更好理解一些。 再看这个过程，我们其实是从右向左找到第一个数字不再递增的位置，然后从右边找到一个刚好大于当前位的数字即可。 再看下代码吧。 public void nextPermutation(int[] nums) { int i = nums.length - 2; //找到第一个不再递增的位置 while (i >= 0 && nums[i + 1] = 0 && nums[j] 时间复杂度：最坏的情况就是遍历完所有位，O（n），倒置也是 O（n），所以总体依旧是 O（n）。 空间复杂度：O（1）。 总 开始看题的时候一直没理解，后来理解了题试了几种也没想出来，然后看了 Solution，理了下思路。 "},"leetCode-32-Longest-Valid-Parentheses.html":{"url":"leetCode-32-Longest-Valid-Parentheses.html","title":"32. Longest Valid Parentheses","keywords":"","body":" 题目描述（困难难度） 解法一 暴力解法 解法二 暴力破解优化 解法三 动态规划 解法四 使用栈 解法五 神奇解法 总 题目描述（困难难度） 给一个一堆括号的字符串，然后返回最长的合法的括号的长度。关于括号的问题，我们在 20 题和 22 题也讨论过。 解法一 暴力解法 列举所有的字符串，然后判断每个字符串是不是符合。当然这里可以做个优化就是，因为合法字符串一定是偶数个，所以可以只列举偶数长度的字符串。列举从 0 开始的，长度是 2、4、6 ……的字符串，列举下标从 1 开始的，长度是 2、4、6 ……的字符串，然后循环下去。当然判断字符串是否符合，利用栈来实现，在之前已经讨论过了。 public boolean isValid(String s) { Stack stack = new Stack(); for (int i = 0; i 时间复杂度: 列举字符串是 O（n²），判断是否是合法序列是 O（n），所以总共是 O（n³）。 空间复杂度：O（n），每次判断的时候，栈的大小。 这个算法，leetCode 会报时间超时。 解法二 暴力破解优化 解法一中，我们会做很多重复的判断，例如类似于这样的，（）（）（），从下标 0 开始，我们先判断长度为 2 的是否是合法序列。然后再判断长度是 4 的字符串是否符合，但会从下标 0 开始判断。判断长度为 6 的字符串的时候，依旧从 0 开始，但其实之前已经确认前 4 个已经组成了合法序列，所以我们其实从下标 4 开始判断就可以了。 基于此，我们可以换一个思路，我们判断从每个位置开始的最长合法子串是多长即可。而判断是否是合法子串，我们不用栈，而是用一个变量记录当前的括号情况，遇到左括号加 1，遇到右括号减 1，如果变成 0 ，我们就更新下最长合法子串。 public int longestValidParentheses(String s) { int count = 0; int max = 0; for (int i = 0; i max) { max = j - i + 1; } } } } return max; } 时间复杂度：O（n²）。 空间复杂度：O（1）。 解法三 动态规划 首先定义动态规划的数组代表什么 dp [ i ] 代表以下标 i 结尾的合法序列的最长长度，例如下图 下标 1 结尾的最长合法字符串长度是 2，下标 3 结尾的最长字符串是 str [ 0 , 3 ]，长度是 4 。 我们来分析下 dp 的规律。 首先我们初始化所有的 dp 都等于零。 以左括号结尾的字符串一定是非法序列，所以 dp 是零，不用更改。 以右括号结尾的字符串分两种情况。 右括号前边是 ( ，类似于 ……（）。 dp [ i ] = dp [ i - 2] + 2 （前一个合法序列的长度，加上当前新增的长度 2） 类似于上图中 index = 3 的时候的情况。 dp [ 3 ] = dp [ 3 - 2 ] + 2 = dp [ 1 ] + 2 = 2 + 2 = 4 右括号前边是 )，类似于 ……））。 此时我们需要判断 i - dp[i - 1] - 1 （前一个合法序列的前边一个位置） 是不是左括号。 例如上图的 index = 7 的时候，此时 index - 1 也是右括号，我们需要知道 i - dp[i - 1] - 1 = 7 - dp [ 6 ] - 1 = 4 位置的括号的情况。 而刚好 index = 4 的位置是左括号，此时 dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1] - 2 ] + 2 （当前位置的前一个合法序列的长度，加上匹配的左括号前边的合法序列的长度，加上新增的长度 2），也就是 dp [ 7 ] = dp [ 7 - 1 ] + dp [ 7 - dp [ 7 - 1] - 2 ] + 2 = dp [ 6 ] + dp [7 - 2 - 2] + 2 = 2 + 4 + 2 = 8。 如果 index = 4 不是左括号，那么此时位置 7 的右括号没有匹配的左括号，所以 dp [ 7 ] = 0 ，不需要更新。 上边的分析可以结合图看一下，可以更好的理解，下边看下代码。 public int longestValidParentheses(String s) { int maxans = 0; int dp[] = new int[s.length()]; for (int i = 1; i = 2 ? dp[i - 2] : 0) + 2; //右括号前边是右括号，并且除去前边的合法序列的前边是左括号 } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } 时间复杂度：遍历了一次，O（n）。 空间复杂度：O（n）。 解法四 使用栈 从左到右扫描字符串，栈顶保存当前扫描的时候，合法序列前的一个位置位置下标是多少，啥意思嘞？ 我们扫描到左括号，就将当前位置入栈。 扫描到右括号，就将栈顶出栈（代表栈顶的左括号匹配到了右括号），然后分两种情况。 栈不空，那么就用当前的位置减去栈顶的存的位置，然后就得到当前合法序列的长度，然后更新一下最长长度。 栈是空的，说明之前没有与之匹配的左括号，那么就将当前的位置入栈。 看下图示，更好的理解一下。 再看下代码 public int longestValidParentheses(String s) { int maxans = 0; Stack stack = new Stack<>(); stack.push(-1); for (int i = 0; i 时间复杂度： O（n）。 空间复杂度：O（n）。 解法五 神奇解法 保持时间复杂度是 O（n），将空间复杂度优化到了 O（1），它的动机是怎么想到的没有理出来，就介绍下它的想法吧。 从左到右扫描，用两个变量 left 和 right 保存的当前的左括号和右括号的个数，都初始化为 0 。 如果左括号个数等于右括号个数了，那么就更新合法序列的最长长度。 如果左括号个数大于右括号个数了，那么就接着向右边扫描。 如果左括号数目小于右括号个数了，那么后边无论是什么，此时都不可能是合法序列了，此时 left 和 right 归 0，然后接着扫描。 从左到右扫描完毕后，同样的方法从右到左再来一次，因为类似这样的情况 ( ( ( ) ) ，如果从左到右扫描到最后，left = 3，right = 2，期间不会出现 left == right。但是如果从右向左扫描，扫描到倒数第二个位置的时候，就会出现 left = 2，right = 2 ，就会得到一种合法序列。 public int longestValidParentheses(String s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i = left) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i >= 0; i--) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * left); } else if (left >= right) { left = right = 0; } } return maxlength; } 时间复杂度：O（n）。 空间复杂度：O（1）。 总 这几种算法，暴力破解和动态规划我觉得想的话，还是能分析出来的话，最后两种算法感觉是去挖掘题的本质得到的算法，普适性不是很强。但最后一种算法，从左到右，从右到左，是真的强。 "},"leetCode-33-Search-in-Rotated-Sorted-Array.html":{"url":"leetCode-33-Search-in-Rotated-Sorted-Array.html","title":"33. Search in Rotated Sorted Array","keywords":"","body":" 题目描述（中等难度） 解法一 解法二 解法三 总 题目描述（中等难度） 开始的时候想复杂了，其实就是一个排序好的数组，把前边的若干的个数，一起移动到末尾就行了。然后在 log (n) 下找到给定数字的下标。 总的来说，log（n），我们肯定得用二分的方法了。 解法一 参考这里-Binary-search-solution)首先我们想一下变化前，正常的升序。我们怎么找给定的数字。 我们每次只关心中间位置的值（这一点很重要），也就是上图 3 位置的数值，如果 target 小于 3 位置的值，我们就把 3 4 5 6 抛弃。然后看新的中间的位置，也就是 1 位置的数值。 3 位置， 1 位置的值是多少呢？我们有一个数组。 3 位置的值，刚好就是数组下标为 3 的值，1 位置的值刚好就是下标为 1 的值。 那么如果，按题目要求的，变化后，3 位置 和 1 位置的值怎么求呢？ 此时我们的数组变成下边这样，我们依旧把值从小到大排列。 此时 3 位置的数值对应为数组下标是 0 的值，1 位置的值对应数组下标是 5 的值。任意位置的对应规则是什么呢？0 -> 4, 1 - > 5，4 ->1，就是就是 （位置 + 偏移 % 数组的长度）。这里就是加上 4 模 7。 问题转换为怎么去求出这个偏移。 我们只要知道任意一个位置对应的数组下标就可以了，为了方便我们可以求位置为 0 的值对应的下标（数组中最小的数对应的下标），0 位置对应的下标就是我们要求的偏移了（0 + 偏移 = 数组下标）。这里 nums = [ 4, 5, 6, 7, 0, 1, 2] ，我们就需要去求数值 0 的下标。 求最小值的下标，因为题目要求时间复杂度是 O（log ( n )），所以我们必须采取二分的方法去找，二分的方法就要保证每次比较后，去掉一半的元素。这里我们去比较中点和端点值的情况，那么是根据中点和起点比较，还是中点和终点比较呢？我们来分析下。 mid 和 start 比较 mid > start : 最小值在左半部分。 mid 无论大于小于，最小值都在左半部分，所以 mid 和 start 比较是不可取的。 mid 和 end 比较 mid mid > end：最小值在右半部分。 所以我们只需要把 mid 和 end 比较，mid end 丢弃左半部分（更新 start = mid）。直到 end 等于 start 时候结束就可以了。 但这样会有一个问题的，对于下边的例子，就会遇到死循环了。 问题出在，当数组剩偶数长度的时候，mid = （start + end）/ 2，mid 取的是左端点。上图的例子， mid > end, 更新 start = mid，start 位置并不会变化。那么下一次 mid 的值也不会变，就死循环了。所以，我们要更新 start = mid + 1。 综上，找最小值的下标的代码就出来了，同时，由于我们找的是位置 0 对应的下标，所以偏移就是最小值的下标。 while (start nums[end]) { start = mid + 1 ; } else { end = mid; } } int bias = start; 当然，我们是找最小值对应的下标，然后求出了偏移。我们也可以找最大值的对应的下标，分析思路和之前是一样的，主要还是要注意一下边界的情况，然后就可以求出偏移。 while (start 有了偏移，我们就可以愉快的找目标值的数组下标了。 public int search (int[] nums, int target) { int start = 0; int end = nums.length - 1; //找出最小值的数组下标 /* while (start nums[end]) { start = mid + 1 ; } else { end = mid; } } int bias = start;*/ //找出最大值的数组下标 while (start 时间复杂度：O（log（n））。 空间复杂度：O（1）。 解法二 参考这里，题目中的数组，其实是两段有序的数组。例如 [ 4 5 6 7 1 2 3 ] ，[ 4 5 6 7 ] 和 [ 1 2 3 ] 两段有序。 而对于 [ 1 2 3 4] 这种，可以看做 [ 1 2 3 4 ] 和 [ ] 特殊的两段有序。 而对于我们要找的 target ， target 不在的那一段，所有数字可以看做无穷大，这样整个数组就可以看做有序的了，可以用正常的二分法去找 target 了，例如 [ 4 5 6 7 1 2 3] ，如果 target = 5，那么数组可以看做 [ 4 5 6 7 inf inf inf ]。 [ 4 5 6 7 1 2 3] ，如果 target = 2，那么数组可以看做 [ -inf -inf - inf -inf 1 2 3]。 和解法一一样，我们每次只关心 mid 的值，所以 mid 要么就是 nums [ mid ]，要么就是 inf 或者 -inf。 什么时候是 nums [ mid ] 呢？ 当 nums [ mid ] 和 target 在同一段里边。 怎么判断 nums [ mid ] 和 target 在同一段？ 把 nums [ mid ] 和 target 同时与 nums [ 0 ] 比较，如果它俩都大于 nums [ 0 ] 或者都小于 nums [ 0 ]，那么就代表它俩在同一段。例如 [ 4 5 6 7 1 2 3]，如果 target = 5，此时数组看做 [ 4 5 6 7 inf inf inf ]。nums [ mid ] = 7，target > nums [ 0 ]，nums [ mid ] > nums [ 0 ]，所以它们在同一段 nums [ mid ] = 7，不用变化。 怎么判断 nums [ mid ] 和 target 不在同一段？ 把 nums [ mid ] 和 target 同时与 nums [ 0 ] 比较，如果它俩一个大于 nums [ 0 ] 一个小于 nums [ 0 ]，那么就代表它俩不在同一段。例如 [ 4 5 6 7 1 2 3]，如果 target = 2，此时数组看做 [ - inf - inf - inf - inf 1 2 3]。nums [ mid ] = 7，target nums [ 0 ]，一个大于，一个小于，所以它们不在同一段 nums [ mid ] = - inf，变成了负无穷大。 看下代码吧 public int search(int[] nums, int target) { int lo = 0, hi = nums.length - 1; while (lo target) hi = mid - 1; else return mid; } return -1; } 时间复杂度：O（log（n））。 空间复杂度：O（1）。 解法三 参考这里，算法基于一个事实，数组从任意位置劈开后，至少有一半是有序的，什么意思呢？ 比如 [ 4 5 6 7 1 2 3] ，从 7 劈开，左边是 [ 4 5 6 7] 右边是 [ 7 1 2 3]，左边是有序的。 基于这个事实。 我们可以先找到哪一段是有序的 (只要判断端点即可)，然后看 target 在不在这一段里，如果在，那么就把另一半丢弃。如果不在，那么就把这一段丢弃。 public int search(int[] nums, int target) { int start = 0; int end = nums.length - 1; while (start = nums[start] && target nums[mid] && target 时间复杂度：O（log（n））。 空间复杂度：O（1）。 总 三种解法是从不同的思路去理解题意，但本质上都是找到丢弃一半的规则，从而达到 log （n） 的时间复杂度，对二分查找的本质的理解更加深刻了。 "},"leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html":{"url":"leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html","title":"34. Find First and Last Position of Element in Sorted Array","keywords":"","body":" 题目描述（中等难度） 解法一 线性扫描 解法二 二分查找 解法三 总 题目描述（中等难度） 找到目标值的第一次出现和最后一次出现的位置，同样要求 log ( n ) 下完成。 先分享 leetcode 提供的两个解法。 解法一 线性扫描 从左向右遍历，一旦出现等于 target 的值就结束，保存当前下标。如果从左到右没有找到 target，那么就直接返回 [ -1 , -1 ] 就可以了，因为从左到右没找到，那么从右到左也一定不会找到的。如果找到了，然后再从右到左遍历，一旦出现等于 target 的值就结束，保存当前下标。 时间复杂度是 O（n）并不满足题意，但可以了解下这个思路，从左到右，从右到左之前也遇到过。 public int[] searchRange(int[] nums, int target) { int[] targetRange = {-1, -1}; // 从左到右扫描 for (int i = 0; i = 0; j--) { if (nums[j] == target) { targetRange[1] = j; break; } } return targetRange; } 时间复杂度：O（n）。 空间复杂度：O（1）。 解法二 二分查找 让我们先看下正常的二分查找。 int start = 0; int end = nums.length - 1; while (start 二分查找中，我们找到 target 就结束了，这里我们需要修改下。 我们如果找最左边等于 target 的值，找到 target 时候并不代表我们找到了我们所需要的，例如下边的情况， 此时虽然 mid 指向的值等于 target 了，但是我们要找的其实还在左边，为了达到 log 的时间复杂度，我们依旧是丢弃一半，我们需要更新 end = mid - 1，图示如下。 此时 tartget > nums [ mid ] ，更新 start = mid + 1。 此时 target == nums [ mid ] ，但由于我们改成了 end = mid - 1，所以继续更新，end 就到了 mid 的左边，此时 start > end 了，就会走出 while 循环， 我们要找的值刚好就是 start 指向的了。那么我们修改的代码如下： while (start 找右边的同样的分析思路，就是判断需要丢弃哪一边。 所以最后的代码就出来了。leetcode 中是把找左边和找右边的合并起来了，本质是一样的。 public int[] searchRange(int[] nums, int target) { int start = 0; int end = nums.length - 1; int[] ans = { -1, -1 }; if (nums.length == 0) { return ans; } while (start 时间复杂度：O（log（n））。 空间复杂度：O（1）。 解法三 以上是 leetcode 提供的思路，我觉得不是很好，因为它所有的情况都一定是循环 log（n）次，讲一下我最开始想到的。 相当于在解法二的基础上优化了一下，下边是解法二的代码。 while (start 考虑下边的一种情况，如果我们找最左边等于 target 的，此时 mid 的位置已经是我们要找的了，而解法二更新成了 end = mid - 1，然后继续循环了，而此时我们其实完全可以终止了。只需要判断 nums[ mid - 1] 是不是小于 nums [ mid ] ，如果小于就刚好是我们要找的了。 当然，找最右边也是同样的思路，看下代码吧。 public int[] searchRange(int[] nums, int target) { int start = 0; int end = nums.length - 1; int[] ans = { -1, -1 }; if (nums.length == 0) { return ans; } while (start n 一定成立，我们把 n 赋成最小值 //如果 mid > 0，直接吧 nums[mid - 1] 赋给 n 就可以了。 int n = mid > 0 ? nums[mid - 1] : Integer.MIN_VALUE; if (target > n) { ans[0] = mid; break; } end = mid - 1; } else if (target 时间复杂度：O（log（n））。 空间复杂度：O（1）。 总 总体来说，这道题并不难，本质就是对二分查找的修改，以便满足我们的需求。 "},"leetCode-79-Word-Search.html":{"url":"leetCode-79-Word-Search.html","title":"79. Word Search","keywords":"","body":" 题目描述（中等难度） 总 题目描述（中等难度） 意思就是从某个字符出发，然后它可以向左向右向上向下移动，走过的路径构成一个字符串，判断是否能走出给定字符串的 word ，还有一个条件就是走过的字符不能够走第二次。 比如 SEE，从第二行最后一列的 S 出发，向下移动，再向左移动，就走出了 SEE。 ABCB，从第一行第一列的 A 出发，向右移动，再向右移动，到达 C 以后，不能向左移动回到 B ，并且也没有其他的路径走出 ABCB 所以返回 false。 这种题，如果用迭代一眼想不到结果，就得考虑递归或者动态规划的方法了。 而递归的话，一定要理清我们的思路，我一般用三步走的思路，可以看下这里 第一步，假定我们有这么个函数 boolean isExist(int current_i,int current_j,String word,char[][]board) 从第 current_i 行和第 current_j 列的字符开始，是否能找到 word 的路径。 第二步，我们要理清楚，怎么从降低规模 我们只需要知道从第 current_i 行和第 current_j 列的字符开始，看能否找到 word 的第一个字符，假如找到的字符的位置是 new_i，new_j，那么我们只要再知道 isExist ( new_i，new_j，word.substring(1),board) 返回值就可以了，也就是从新的位置开始，能否找到除去 word 的第一个字符的字符串。 怎么从第 current_i 和第 current_j 开始，找到 word 的第一个字符，我只需要分别判断第 current_i 行和第 current_j 列的字符的上边、下边、左边、右边的字符是否等于 word 的第一个字符就可以了。 第三步，递归出口 如果传进来的 word 长度是 0 了，我们只需要返回 true 就可以了。 递归思路理清了，还有一个问题就是，怎么保证不重复选取字符，我们利用一个和 board 等大的数组 visited，保存每个字符是否被选上就可以了。 static boolean[][] visited; public boolean exist(char[][] board, String word) { visited = new boolean[board.length][board[0].length];//默认初始值是 false for (int i = 0; i =0&&board[current_i-1][current_j]==word.charAt(0)&&!visited[current_i-1][current_j] &&isExist(current_i-1,current_j,word.substring(1),board); boolean bottom=current_i+1=0&&board[current_i][current_j-1]==word.charAt(0)&&!visited[current_i][current_j-1] &&isExist(current_i,current_j-1,word.substring(1),board); boolean right=current_j+1 时间复杂度：递归的，暂时理不清。 空间复杂度：O（m * n），m 是 board 的行数，n 是 board 的列数。 看到了 leetCode 上一个人的解答，简直神奇！他把空间复杂度优化到了常数空间，怎么做的呢？ 就是把选中的字符的值，改成一个不可能和其他字符相等的值，这样在找和 word 的第一个字符相等的字符的时候，就永远不会找到之前选中的字符了。 开始假设字符被选中的时候，我们将其改成 board[current_i][current_j]='#' 这样到最后，如果它没被选中就还原，怎么还原？原来的值似乎找不到了，所以我们应该找一种可逆的操作。 我们可以用异或，因为字符值的范围是 0 - 255，二进制的话就是 0000 0000 - 1111 1111，我们把它和 256 做异或，也就是和 1 0000 0000 。这样，如果想还原原来的数字只需要再异或 256 就可以了。 看起来有些复杂，其实我们也可以假设选中的时候，把它加上 256，这样它就不可能和其他字符相等了。如果假设失败了，再减去 256 就还原为原来的数字了。 public boolean exist(char[][] board, String word) { visited = new boolean[board.length][board[0].length];//默认初始值是 false for (int i = 0; i =0&&board[current_i-1][current_j]==word.charAt(0) &&isExist(current_i-1,current_j,word.substring(1),board); boolean bottom=current_i+1=0&&board[current_i][current_j-1]==word.charAt(0) &&isExist(current_i,current_j-1,word.substring(1),board); boolean right=current_j+1 总 这种题基本是算法模仿选择的过程就行了，关键就是把问题理清。异或操作优化了空间复杂度，真的佩服！ "}}
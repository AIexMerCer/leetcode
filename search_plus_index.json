{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode 地址 https://leetcode.com/problemset/all/ 准备刷一道，总结一道。 可以加好友一起交流。 QQ 648917857 微信 17771420231 github 地址：https://github.com/wind-liang/leetcode gitbook 预览地址：http://leetcode.windliang.cc 如果觉得对你有帮助，记得给一个 star 哦 ^ ^ "},"leetCode-1-Two-Sum.html":{"url":"leetCode-1-Two-Sum.html","title":"1. Two Sum","keywords":"","body":"题目描述 （简单难度） 给定一个数组和一个目标和，从数组中找两个数字相加等于目标和，输出这两个数字的下标。 解法一 简单粗暴些，两重循环，遍历所有情况看相加是否等于目标和，如果符合直接输出。 public int[] twoSum1(int[] nums, int target) { int []ans=new int[2]; for(int i=0;i 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 解法二 在上边的解法中看下第二个 for 循环步骤。 for(int j=(i+1);j 我们换个理解方式： for(int j=(i+1);j 第二层 for 循环无非是遍历所有的元素，看哪个元素等于 sub ，时间复杂度为 O（n）。 有没有一种方法，不用遍历就可以找到元素里有没有等于 sub 的？ hash table ！！！ 我们可以把数组的每个元素保存为 hash 的 key，下标保存为 hash 的 value 。 这样只需判断 sub 在不在 hash 的 key 里就可以了，而此时的时间复杂度仅为 O（1）！ 需要注意的地方是，还需判断找到的元素不是当前元素，因为题目里讲一个元素只能用一次。 public int[] twoSum2(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 时间复杂度：比解法一少了一个 for 循环，降为 O（n） 空间复杂度：所谓的空间换时间，这里就能体现出来， 开辟了一个 hash table ，空间复杂度变为 O（n） 解法三 看解法二中，两个 for 循环，他们长的一样，我们当然可以把它合起来。复杂度上不会带来什么变化，变化仅仅是不需要判断是不是当前元素了，因为当前元素还没有添加进 hash 里。 public int[] twoSum3(int[] nums, int target) { Map map=new HashMap<>(); for(int i=0;i 总结 题目比较简单，毕竟暴力的方法也可以解决。唯一闪亮的点就是，时间复杂度从 O（n²）降为 O（n） 的时候，对 hash 的应用，有眼前一亮的感觉。 "},"leetCode-2-Add-Two-Numbers.html":{"url":"leetCode-2-Add-Two-Numbers.html","title":"2. Add Two Numbers","keywords":"","body":"题目描述（中等难度） 就是两个链表表示的数相加，这样就可以实现两个很大的数相加了，无需考虑数值 int ，float 的限制了。 由于自己实现的很乱，直接按答案的讲解了。 图示 链表最左边表示个位数，代表 342 + 465 =807 。 思路 首先每一位相加肯定会产生进位，我们用 carry 表示。进位最大会是 1 ，因为最大的情况是无非是 9 + 9 + 1 = 19 ，也就是两个最大的数相加，再加进位，这样最大是 19 ，不会产生进位 2 。下边是伪代码。 初始化一个节点的头，dummy head ，但是这个头不存储数字。并且将 curr 指向它。 初始化进位 carry 为 0 。 初始化 p 和 q 分别为给定的两个链表 l1 和 l2 的头，也就是个位。 循环，直到 l1 和 l2 全部到达 null 。 设置 x 为 p 节点的值，如果 p 已经到达了 null，设置 x 为 0 。 设置 y 为 q 节点的值，如果 q 已经到达了 null，设置 y 为 0 。 设置 sum = x + y + carry 。 更新 carry = sum / 10 。 创建一个值为 sum mod 10 的节点，并将 curr 的 next 指向它，同时 curr 指向变为当前的新节点。 向前移动 p 和 q 。 判断 carry 是否等于 1 ，如果等于 1 ，在链表末尾增加一个为 1 的节点。 返回 dummy head 的 next ，也就是个位数开始的地方。 初始化的节点 dummy head 没有存储值，最后返回 dummy head 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的 head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。 代码 class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry > 0) { curr.next = new ListNode(carry); } return dummyHead.next; } 时间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。 空间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。而其实新的 List 最大长度是 O（max（m，n））+ 1，因为我们的 head 没有存储值。 扩展 如果链表存储的顺序反过来怎么办？ 我首先想到的是链表先逆序计算，然后将结果再逆序呗，这就转换到我们之前的情况了。不知道还有没有其他的解法。下边分析下单链表逆序的思路。 迭代思想 首先看一下原链表。 总共需要添加两个指针，pre 和 next。 初始化 pre 指向 NULL 。 然后就是迭代的步骤，总共四步，顺序一步都不能错。 next 指向 head 的 next ，防止原链表丢失 head 的 next 从原来链表脱离，指向 pre 。 pre 指向 head head 指向 next 一次迭代就完成了，如果再进行一次迭代就变成下边的样子。 可以看到整个过程无非是把旧链表的 head 取下来，添加的新的链表上。代码怎么写呢？ next = head -> next; //保存 head 的 next , 以防取下 head 后丢失 head -> next = pre; //将 head 从原链表取下来，添加到新链表上 pre = head;// pre 右移 head = next; // head 右移 接下来就是停止条件了，我们再进行一次循环。 可以发现当 head 或者 next 指向 null 的时候，我们就可以停止了。此时将 pre 返回，便是逆序了的链表了。 迭代代码 public ListNode reverseList(ListNode head){ if(head==null) return null; ListNode pre=null; ListNode next; while(head!=null){ next=head.next; head.next=pre; pre=head; head=next; } return pre; } 递归思想 首先假设我们实现了将单链表逆序的函数，ListNode reverseListRecursion(ListNode head) ，传入链表头，返回逆序后的链表头。 接着我们确定如何把问题一步一步的化小，我们可以这样想。 把 head 结点拿出来，剩下的部分我们调用函数 reverseListRecursion ，这样剩下的部分就逆序了，接着我们把 head 结点放到新链表的尾部就可以了。这就是整个递归的思想了。 ​ head 结点拿出来 剩余部分调用逆序函数 reverseListRecursion ，并得到了 newhead 将 2 指向 1 ，1 指向 null，将 newhead 返回即可。 找到递归出口 当然就是如果结点的个数是一个，那么逆序的话还是它本身，直接 return 就够了。怎么判断结点个数是不是一个呢？它的 next 等于 null 就说明是一个了。但如果传进来的本身就是 null，那么直接找它的 next 会报错，所以先判断传进来的是不是 null ，如果是，也是直接返回就可以了。 代码 public ListNode reverseListRecursion(ListNode head){ ListNode newHead; if(head==null||head.next==null ){ return head; } newHead=reverseListRecursion(head.next); //head.next 作为剩余部分的头指针 head.next.next=head; //head.next 代表新链表的尾，将它的 next 置为 head，就是将 head 加到最后了。 head.next=null; return newHead; } "},"leetCode-3-Longest-Substring-Without-Repeating-Characters.html":{"url":"leetCode-3-Longest-Substring-Without-Repeating-Characters.html","title":"3. Longest Substring Without Repeating Characters","keywords":"","body":"题目描述（中等难度） 给定一个字符串，找到没有重复字符的最长子串，返回它的长度。 解法一 简单粗暴些，找一个最长子串，那么我们用两个循环穷举所有子串，然后再用一个函数判断该子串中有没有重复的字符。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0;//保存当前得到满足条件的子串的最大值 for (int i = 0; i set = new HashSet<>();//初始化 hash set for (int i = start; i 时间复杂度：两个循环，加上判断子串满足不满足条件的函数中的循环，O（n³）。 空间复杂度：使用了一个 set，判断子串中有没有重复的字符。由于 set 中没有重复的字符，所以最长就是整个字符集，假设字符集的大小为 m ，那么 set 最长就是 m 。另一方面，如果字符串的长度小于 m ，是 n 。那么 set 最长也就是 n 了。综上，空间复杂度为 O（min（m，n））。 解法二 遗憾的是上边的算法没有通过 leetCode，时间复杂度太大，造成了超时。我们怎么来优化一下呢？ 上边的算法中，我们假设当 i 取 0 的时候， j 取 1，判断字符串 str[0,1) 中有没有重复的字符。 j 取 2，判断字符串 str[0,2) 中有没有重复的字符。 j 取 3，判断字符串 str[0,3) 中有没有重复的字符。 j 取 4，判断字符串 str[0,4) 中有没有重复的字符。 做了很多重复的工作，因为如果 str[0,3) 中没有重复的字符，我们不需要再判断整个字符串 str[0,4) 中有没有重复的字符，而只需要判断 str[3] 在不在 str[0,3) 中，不在的话，就表明 str[0,4) 中没有重复的字符。 如果在的话，那么 str[0,5) ，str[0,6) ，str[0,7) 一定有重复的字符，所以此时后边的 j 也不需要继续增加了。i ++ 进入下次的循环就可以了。 此外，我们的 j 也不需要取 j + 1，而只需要从当前的 j 开始就可以了。 综上，其实整个关于 j 的循环我们完全可以去掉了，此时可以理解变成了一个「滑动窗口」。 整体就是橘色窗口在依次向右移动。 判断一个字符在不在字符串中，我们需要可以遍历整个字符串，遍历需要的时间复杂度就是 O（n），加上最外层的 i 的循环，总体复杂度就是 O（n²）。我们可以继续优化，判断字符在不在一个字符串，我们可以将已有的字符串存到 Hash 里，这样的时间复杂度是 O（1），总的时间复杂度就变成了 O（n）。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); Set set = new HashSet<>(); int ans = 0, i = 0, j = 0; while (i 时间复杂度：在最坏的情况下，while 循环中的语句会执行 2n 次，例如 abcdefgg，开始的时候 j 一直后移直到到达第二个 g 的时候固定不变 ，然后 i 开始一直后移直到 n ，所以总共执行了 2n 次，时间复杂度为 O（n）。 空间复杂度：和上边的类似，需要一个 Hash 保存子串，所以是 O（min（m，n））。 解法三 继续优化，我们看上边的算法的一种情况。 当 j 指向的 c 存在于前边的子串 abcd 中，此时 i 向前移到 b ,此时子串中仍然含有 c，还得继续移动，所以这里其实可以优化。我们可以一步到位，直接移动到子串 c 的位置的下一位！ 实现这样的话，我们将 set 改为 map ，将字符存为 key ，将对应的下标存到 value 里就实现了。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map map = new HashMap<>(); for (int j = 0, i = 0; j 与解法二相比 由于采取了 i 跳跃的形式，所以 map 之前存的字符没有进行 remove ，所以 if 语句中进行了Math.max ( map.get ( s.charAt ( j ) ) , i )，要确认得到的下标不是 i 前边的。 还有个不同之处是 j 每次循环都进行了自加 1 ，因为 i 的跳跃已经保证了 str[ i , j] 内没有重复的字符串，所以 j 直接可以加 1 。而解法二中，要保持 j 的位置不变，因为不知道和 j 重复的字符在哪个位置。 最后个不同之处是， ans 在每次循环中都进行更新，因为 ans 更新前 i 都进行了更新，已经保证了当前的子串符合条件，所以可以更新 ans 。而解法二中，只有当当前的子串不包含当前的字符时，才进行更新。 时间复杂度：我们将 2n 优化到了 n ，但最终还是和之前一样，O（n）。 空间复杂度：也是一样的，O（min（m，n)）。 解法四 和解法三思路一样，区别的地方在于，我们不用 Hash ，而是直接用数组，字符的 ASCII 码值作为数组的下标，数组存储该字符所在字符串的位置。适用于字符集比较小的情况，因为我们会直接开辟和字符集等大的数组。 public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; int[] index = new int[128]; for (int j = 0, i = 0; j 和解法 3 不同的地方在于，没有了 if 的判断，因为如果 index[ s.charAt ( j ) ] 不存在的话，它的值会是 0 ，对最终结果不会影响。 时间复杂度：O（n）。 空间复杂度：O（m），m 代表字符集的大小。这次不论原字符串多小，都会利用这么大的空间。 总结 综上，我们一步一步的寻求可优化的地方，对算法进行了优化。又加深了 Hash 的应用，以及利用数组巧妙的实现了 Hash 的作用。 "},"leetCode-4-Median-of-Two-Sorted-Arrays.html":{"url":"leetCode-4-Median-of-Two-Sorted-Arrays.html","title":"4. Median of Two Sorted Arrays","keywords":"","body":"题目描述（困难难度） 已知两个有序数组，找到两个数组合并后的中位数。 解法一 简单粗暴，先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。 代码 public double findMedianSortedArrays(int[] nums1, int[] nums2) { int[] nums; int m = nums1.length; int n = nums2.length; nums = new int[m + n]; if (m == 0) { if (n % 2 == 0) { return (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0; } else { return nums2[n / 2]; } } if (n == 0) { if (m % 2 == 0) { return (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0; } else { return nums1[m / 2]; } } int count = 0; int i = 0, j = 0; while (count != (m + n)) { if (i == m) { while (j != n) { nums[count++] = nums2[j++]; } break; } if (j == n) { while (i != m) { nums[count++] = nums1[i++]; } break; } if (nums1[i] 时间复杂度：遍历全部数组，O（m + n） 空间复杂度：开辟了一个数组，保存合并后的两个数组，O（m + n） 解法二 其实，我们不需要将两个数组真的合并，我们只需要找到中位数在哪里就可以了。 开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了 for 循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。然后在 这里 找到了另一种思路。 首先是怎么将奇数和偶数的情况合并一下。 用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len + 1）/ 2 个数就可以了，如果遍历的话需要遍历 int ( len / 2 ) + 1 次。如果是偶数，我们需要知道第 len / 2 和 len / 2 + 1 个数，也是需要遍历 len / 2 + 1 次。所以遍历的话，奇数和偶数都是 len / 2 + 1 次。 返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right ，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left 。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。 循环中该怎么写，什么时候 A 数组后移，什么时候 B 数组后移。用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart ＜ m && A[aStart] 但如果 B 数组此刻已经没有数字了，继续取数字B [ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 aStart ＜ m && ( bStart >= n || A [ aStart ] 代码 public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; int len = m + n; int left = -1, right = -1; int aStart = 0, bStart = 0; for (int i = 0; i = n || A[aStart] 时间复杂度：遍历 len/2 + 1 次，len = m + n ，所以时间复杂度依旧是 O（m + n）。 空间复杂度：我们申请了常数个变量，也就是 m，n，len，left，right，aStart，bStart 以及 i 。 总共 8 个变量，所以空间复杂度是 O（1）。 解法三 上边的两种思路，时间复杂度都达不到题目的要求 O ( log ( m + n ) )。看到 log ，很明显，我们只有用到二分的方法才能达到。我们不妨用另一种思路，题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。 解法二中，我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k / 2 个数。看下边一个例子。 假设我们要找第 7 小的数字。 我们比较两个数组的第 k / 2 个数字，如果 k 是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 8 和 下边数组中的 3 ，如果哪个小，就表明该数组的前 k / 2 个数字都不是第 k 小数字，所以可以排除。也就是 1，2，3 这三个数字不可能是第 7 小的数字，我们可以把它排除掉。将 1389 和 45678910 两个数组作为新的数组进行比较。 更一般的情况 A [ 1 ]，A [ 2 ]，A [ 3 ]，A [ k / 2] ... ，B[ 1 ]，B [ 2 ]，B [ 3 ]，B[ k / 2] ... ，如果 A [ k / 2 ] A 数组中比 A [ k / 2 ] 小的数有 k / 2 - 1 个，B 数组中，B [ k / 2 ] 比 A [ k / 2 ] 小，假设 B [ k / 2 ] 前边的数字都比 A [ k / 2 ] 小，也只有 k / 2 - 1 个，所以比 A [ k / 2 ] 小的数字最多有 k / 2 - 1 + k / 2 - 1 = k - 2 个，所以 A [ k / 2 ] 最多是第 k - 1 小的数。而比 A [ k / 2 ] 小的数更不可能是第 k 小的数了，所以可以把它们排除。 橙色的部分表示已经去掉的数字。 由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4 。此时两个数组，比较第 2 个数字，3 我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 = 4 ，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 > 4 吧，所以此时将下边的 4 去掉。 由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4 。 所以第 7 小的数字是 4 。 我们每次都是取 k / 2 的数进行比较，有时候可能会遇到数组长度小于 k / 2 的时候。 此时 k / 2 等于 3 ，而上边的数组长度是 2 ，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 由于 2 个元素被排除，所以此时 k = 5 ，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。 从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。 所以我们采用递归的思路，为了防止数组长度小于 k / 2 ，所以每次比较 min ( k / 2，len ( 数组 ) ) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k = 1 或者其中一个数字长度是 0 了。 代码 public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length; int m = nums2.length; int left = (n + m + 1) / 2; int right = (n + m + 2) / 2; //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。 return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5; } private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) { int len1 = end1 - start1 + 1; int len2 = end2 - start2 + 1; //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 if (len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k); if (len1 == 0) return nums2[start2 + k - 1]; if (k == 1) return Math.min(nums1[start1], nums2[start2]); int i = start1 + Math.min(len1, k / 2) - 1; int j = start2 + Math.min(len2, k / 2) - 1; if (nums1[i] > nums2[j]) { return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1)); } else { return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1)); } } 时间复杂度：每进行一次循环，我们就减少 k / 2 个元素，所以时间复杂度是 O（log（k）），而 k = （m + n）/ 2 ，所以最终的复杂也就是 O（log（m + n））。 空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O（1）。 解法四 我们首先理一下中位数的定义是什么 中位数（又称中值，英语：Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。 所以我们只需要将数组进行切。 一个长度为 m 的数组，有 0 到 m 总共 m + 1 个位置可以切。 我们把数组 A 和数组 B 分别在 i 和 j 进行切割。 将 i 的左边和 j 的左边组合成「左半部分」，将 i 的右边和 j 的右边组合成「右半部分」。 当 A 数组和 B 数组的总长度是偶数时，如果我们能够保证 左半部分的长度等于右半部分 i + j = m - i + n - j , 也就是 j = ( m + n ) / 2 - i 左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） 那么，中位数就可以表示如下 （左半部分最大值 + 右半部分最大值 ）/ 2 。 （max ( A [ i - 1 ] , B [ j - 1 ]）+ min ( A [ i ] , B [ j ]）） / 2 当 A 数组和 B 数组的总长度是奇数时，如果我们能够保证 左半部分的长度比右半部分大 1 i + j = m - i + n - j + 1也就是 j = ( m + n + 1) / 2 - i 左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） 那么，中位数就是 左半部分最大值，也就是左半部比右半部分多出的那一个数。 max ( A [ i - 1 ] , B [ j - 1 ]） 上边的第一个条件我们其实可以合并为 j = ( m + n + 1) / 2 - i，因为如果 m + n 是偶数，由于我们取的是 int 值，所以加 1 也不会影响结果。当然，由于 0 m≤n,im,j=(m+n+1)/2−i≥(m+m+1)/2−i>(m+m+1)/2−m=0m\\leq n,i(m+m+1)/2-m=0m≤n,im,j=(m+n+1)/2−i≥(m+m+1)/2−i>(m+m+1)/2−m=0 m≤n,i>0,j=(m+n+1)/2−i≤(n+n+1)/2−i(n+n+1)/2=nm\\leq n,i>0,j=(m+n+1)/2-i\\leq (n+n+1)/2-im≤n,i>0,j=(m+n+1)/2−i≤(n+n+1)/2−i(n+n+1)/2=n 最后一步由于是 int 间的运算，所以 1 / 2 = 0。 而对于第二个条件，奇数和偶数的情况是一样的，我们进一步分析。为了保证 max ( A [ i - 1 ] , B [ j - 1 ]）） B [ j - 1 ] > A [ i ]，并且为了不越界，要保证 j != 0，i != m 此时很明显，我们需要增加 i ，为了数量的平衡还要减少 j ，幸运的是 j = ( m + n + 1) / 2 - i，i 增大，j 自然会减少。 A [ i - 1 ] > B [ j ] ，并且为了不越界，要保证 i != 0，j != n 此时和上边的情况相反，我们要减少 i ，增大 j 。 上边两种情况，我们把边界都排除了，需要单独讨论。 当 i = 0 , 或者 j = 0 ，也就是切在了最前边。 此时左半部分当 j = 0 时，最大的值就是 A [ i - 1 ] ；当 i = 0 时 最大的值就是 B [ j - 1] 。右半部分最小值和之前一样。 当 i = m 或者 j = n ，也就是切在了最后边。 此时左半部分最大值和之前一样。右半部分当 j = n 时，最小值就是 A [ i ] ；当 i = m 时，最小值就是B [ j ] 。 所有的思路都理清了，最后一个问题，增加 i 的方式。当然用二分了。初始化 i 为中间的值，然后减半找中间的，减半找中间的，减半找中间的直到答案。 class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; if (m > n) { return findMedianSortedArrays(B,A); // 保证 m A[i]){ // i 需要增大 iMin = i + 1; } else if (i != 0 && j != n && A[i-1] > B[j]) { // i 需要减小 iMax = i - 1; } else { // 达到要求，并且将边界条件列出来单独考虑 int maxLeft = 0; if (i == 0) { maxLeft = B[j-1]; } else if (j == 0) { maxLeft = A[i-1]; } else { maxLeft = Math.max(A[i-1], B[j-1]); } if ( (m + n) % 2 == 1 ) { return maxLeft; } // 奇数的话不需要考虑右半部分 int minRight = 0; if (i == m) { minRight = B[j]; } else if (j == n) { minRight = A[i]; } else { minRight = Math.min(B[j], A[i]); } return (maxLeft + minRight) / 2.0; //如果是偶数的话返回结果 } } return 0.0; } } 时间复杂度：我们对较短的数组进行了二分查找，所以时间复杂度是 O（log（min（m，n）））。 空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O ( 1 ) 。 总结 解法二中体会到了对情况的转换，有时候即使有了思路，代码也不一定写的优雅，需要多锻炼才可以。解法三和解法四充分发挥了二分查找的优势，将时间复杂度降为 log 级别。 "},"leetCode-5-Longest-Palindromic-Substring.html":{"url":"leetCode-5-Longest-Palindromic-Substring.html","title":"5. Longest Palindromic Substring","keywords":"","body":"题目描述（中等难度） 给定一个字符串，输出最长的回文子串。回文串指的是正的读和反的读是一样的字符串，例如 \"aba\"，\"ccbbcc\"。 解法一 暴力破解 暴力求解，列举所有的子串，判断是否为回文串，保存最长的回文串。 public boolean isPalindromic(String s) { int len = s.length(); for (int i = 0; i max) { ans = s.substring(i, j); max = Math.max(max, ans.length()); } } return ans; } 时间复杂度：两层 for 循环 O（n²），for 循环里边判断是否为回文，O（n），所以时间复杂度为 O（n³）。 空间复杂度：O（1），常数个变量。 解法二 最长公共子串 根据回文串的定义，正着和反着读一样，那我们是不是把原来的字符串倒置了，然后找最长的公共子串就可以了。例如，S = \" caba\"，S' = \" abac\"，最长公共子串是 \"aba\"，所以原字符串的最长回文串就是 \"aba\"。 关于求最长公共子串（不是公共子序列），有很多方法，这里用动态规划的方法，可以先阅读下边的链接。 https://blog.csdn.net/u010397369/article/details/38979077 https://www.kancloud.cn/digest/pieces-algorithm/163624 整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话 arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。 当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。 arr [ i ][ j ] 保存的就是公共子串的长度。 public String longestPalindrome(String s) { if (s.equals(\"\")) return \"\"; String origin = s; String reverse = new StringBuffer(s).reverse().toString(); //字符串倒置 int length = s.length(); int[][] arr = new int[length][length]; int maxLen = 0; int maxEnd = 0; for (int i = 0; i maxLen) { maxLen = arr[i][j]; maxEnd = i; //以 i 位置结尾的字符 } } } return s.substring(maxEnd - maxLen + 1, maxEnd + 1); } 再看一个例子，S = \"abc435cba\"，S’ = \"abc534cba\" ，最长公共子串是 \"abc\" 和 \"cba\" ，但很明显这两个字符串都不是回文串。 所以我们求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配。 比如 S = \" caba \"，S' = \" abac \" ，S’ 中 aba 的下标是 0 1 2 ，倒置前是 3 2 1，和 S 中 aba 的下标符合，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。 首先 i ，j 始终指向子串的末尾字符。所以 j 指向的红色的 a 倒置前的下标是 beforeRev = length - 1 - j = 4 - 1 - 2 = 1，对应的是字符串首位的下标，我们还需要加上字符串的长度才是末尾字符的下标，也就是 beforeRev + arr[ i ] [ j ] - 1 = 1 + 3 - 1 = 3，因为 arr[ i ] [ j ] 保存的就是当前子串的长度，也就是图中的数字 3 。此时再和它与 i 比较，如果相等，则说明它是我们要找的回文串。 之前的 S = \"abc435cba\"，S' = \"abc534cba\" ，可以看一下图示，为什么不符合。 当前 j 指向的 c ，倒置前的下标是 beforeRev = length - 1 - j = 9 - 1 - 2 = 6，对应的末尾下标是 beforeRev + arr[ i ] [ j ] - 1 = 6 + 3 - 1 = 8 ，而此时 i = 2 ，所以当前的子串不是回文串。 代码的话，在上边的基础上，保存 maxLen 前判断一下下标匹不匹配就可以了。 public String longestPalindrome(String s) { if (s.equals(\"\")) return \"\"; String origin = s; String reverse = new StringBuffer(s).reverse().toString(); int length = s.length(); int[][] arr = new int[length][length]; int maxLen = 0; int maxEnd = 0; for (int i = 0; i maxLen) { int beforeRev = length - 1 - j; if (beforeRev + arr[i][j] - 1 == i) { //判断下标是否对应 maxLen = arr[i][j]; maxEnd = i; } /*************************************/ } } return s.substring(maxEnd - maxLen + 1, maxEnd + 1); } 时间复杂度：两层循环，O（n²）。 空间复杂度：一个二维数组，O（n²）。 空间复杂度其实可以再优化一下。 我们分析一下循环，i = 0 ，j = 0，1，2 ... 8 更新一列，然后 i = 1 ，再更新一列，而更新的时候我们其实只需要上一列的信息，更新第 3 列的时候，第 1 列的信息是没有用的。所以我们只需要一个一维数组就可以了。但是更新 arr [ i ] 的时候我们需要 arr [ i - 1 ] 的信息，假设 a [ 3 ] = a [ 2 ] + 1，更新 a [ 4 ] 的时候， 我们需要 a [ 3 ] 的信息，但是 a [ 3 ] 在之前已经被更新了，所以 j 不能从 0 到 8 ，应该倒过来，a [ 8 ] = a [ 7 ] + 1，a [ 7 ] = a [ 6 ] + 1 , 这样更新 a [ 8 ] 的时候用 a [ 7 ] ，用完后才去更新 a [ 7 ]，保证了不会出错。 public String longestPalindrome(String s) { if (s.equals(\"\")) return \"\"; String origin = s; String reverse = new StringBuffer(s).reverse().toString(); int length = s.length(); int[] arr = new int[length]; int maxLen = 0; int maxEnd = 0; for (int i = 0; i = 0; j--) { /**************************************************/ if (origin.charAt(i) == reverse.charAt(j)) { if (i == 0 || j == 0) { arr[j] = 1; } else { arr[j] = arr[j - 1] + 1; } /**************修改的地方***************************/ //之前二维数组，每次用的是不同的列，所以不用置 0 。 } else { arr[j] = 0; } /**************************************************/ if (arr[j] > maxLen) { int beforeRev = length - 1 - j; if (beforeRev + arr[j] - 1 == i) { maxLen = arr[j]; maxEnd = i; } } } return s.substring(maxEnd - maxLen + 1, maxEnd + 1); } 时间复杂度：O（n²）。 空间复杂度：降为 O（n）。 解法三 暴力破解优化 解法一的暴力解法时间复杂度太高，在 leetCode 上并不能 AC 。我们可以考虑，去掉一些暴力解法中重复的判断。我们可以基于下边的发现，进行改进。 首先定义 P（i，j）。 P(i,j)={trues[i,j]是回文串falses[i,j]不是回文串P(i,j)=\\begin{cases}true& \\text{s[i,j]是回文串} \\\\\\\\false& \\text{s[i,j]不是回文串}\\end{cases}P(i,j)=​⎩​⎪​⎨​⎪​⎧​​​true​​false​​​s[i,j]是回文串​s[i,j]不是回文串​​ 接下来 P(i,j)=(P(i+1,j−1)&&S[i]==S[j])P(i,j)=(P(i+1,j-1)\\&\\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j]) 所以如果我们想知道 P（i，j）的情况，不需要调用判断回文串的函数了，只需要知道 P（i + 1，j - 1）的情况就可以了，这样时间复杂度就少了 O（n）。因此我们可以用动态规划的方法，空间换时间，把已经求出的 P（i，j）存储起来。 如果 S[i+1,j−1]S[i+1,j-1]S[i+1,j−1] 是回文串，那么只要 S [ i ] == S [ j ] ，就可以确定 S [ i , j ] 也是回文串了。 求 长度为 1 和长度为 2 的 P ( i , j ) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j]P[i][j]P[i][j] 中 i > j 的情况，比如求 P[1][2]P[1][2]P[1][2] 的话，我们需要知道 P[1+1][2−1]=P[2][1]P[1+1][2-1]=P[2][1]P[1+1][2−1]=P[2][1] ，而 P[2][1]P[2][1]P[2][1] 代表着 S[2,1]S[2,1]S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。 所以我们先初始化长度是 1 的回文串的 P [ i , j ]，这样利用上边提出的公式 P(i,j)=(P(i+1,j−1)&&S[i]==S[j])P(i,j)=(P(i+1,j-1)\\&\\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。 同理，初始化长度是 2 的回文串 P [ i , i + 1 ]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。 public String longestPalindrome(String s) { int length = s.length(); boolean[][] P = new boolean[length][length]; int maxLen = 0; String maxPal = \"\"; for (int len = 1; len = length) //下标已经越界，结束本次循环 break; P[start][end] = (len == 1 || len == 2 || P[start + 1][end - 1]) && s.charAt(start) == s.charAt(end); //长度为 1 和 2 的单独判断下 if (P[start][end] && len > maxLen) { maxPal = s.substring(start, end + 1); } } return maxPal; } 时间复杂度：两层循环，O（n²）。 空间复杂度：用二维数组 P 保存每个子串的情况，O（n²）。 我们分析下每次循环用到的 P（i，j），看一看能不能向解法二一样优化一下空间复杂度。 当我们求长度为 6 和 5 的子串的情况时，其实只用到了 4 ， 3 长度的情况，而长度为 1 和 2 的子串情况其实已经不需要了。但是由于我们并不是用 P 数组的下标进行的循环，暂时没有想到优化的方法。 之后看到了另一种动态规划的思路 https://leetcode.com/problems/longest-palindromic-substring/discuss/2921/Share-my-Java-solution-using-dynamic-programming 。 公式还是这个不变 首先定义 P（i，j）。 P(i,j)={trues[i,j]是回文串falses[i,j]不是回文串P(i,j)=\\begin{cases}true& \\text{s[i,j]是回文串}\\\\\\\\false& \\text{s[i,j]不是回文串}\\end{cases}P(i,j)=​⎩​⎪​⎨​⎪​⎧​​​true​​false​​​s[i,j]是回文串​s[i,j]不是回文串​​ 接下来 P(i,j)=(P(i+1,j−1)&&S[i]==S[j])P(i,j)=(P(i+1,j-1)\\&\\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j]) 递推公式中我们可以看到，我们首先知道了 i +1 才会知道 i ，所以我们只需要倒着遍历就行了。 public String longestPalindrome(String s) { int n = s.length(); String res = \"\"; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i >= 0; i--) { for (int j = i; j res.length()) { res = s.substring(i, j + 1); } } } return res; } 时间复杂度和空间复杂和之前都没有变化，我们来看看可不可以优化空间复杂度。 当求第 i 行的时候我们只需要第 i + 1 行的信息，并且 j 的话需要 j - 1 的信息，所以和之前一样 j 也需要倒叙。 public String longestPalindrome7(String s) { int n = s.length(); String res = \"\"; boolean[] P = new boolean[n]; for (int i = n - 1; i >= 0; i--) { for (int j = n - 1; j >= i; j--) { P[j] = s.charAt(i) == s.charAt(j) && (j - i res.length()) { res = s.substring(i, j + 1); } } } return res; } 时间复杂度：不变，O（n²）。 空间复杂度：降为 O（n ) 。 解法四 扩展中心 我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。 由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n + n - 1 个中心。 public String longestPalindrome(String s) { if (s == null || s.length() end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1); } private int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L >= 0 && R 时间复杂度：O（n²）。 空间复杂度：O（1）。 解法五 Manacher's Algorithm 马拉车算法。 马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 主要参考了下边链接进行讲解。 https://segmentfault.com/a/1190000008484167 https://blog.crimx.com/2017/07/06/manachers-algorithm/ http://ju.outofmemory.cn/entry/130005 https://articles.leetcode.com/longest-palindromic-substring-part-ii/ 首先我们解决下奇数和偶数的问题，在每个字符间插入\"#\"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 \"^\" 和 \"$\"，两个不可能在字符串中出现的字符，这样向解法四那样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 首先我们用一个数组 P 保存从中心扩展的个数，巧合的它也是去掉 \"#\" 的字符串的总长度，可以看下边的图。 用 P 的下标 i 减去 P[i]，再除以 2 ，就是原字符串的开头下标了。 例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第 （5 - 1）位就可以了。 接下来是算法的关键了，它充分利用了回文串的对称性。 我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[i] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。 用 i_mirror 表示当前扩展的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ] 如果是解法四，那就向两边扩展就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ mirror ] = 3，所以 P [ i ] 也等于 3 。 有三种情况将会造成直接赋值为 P [ mirror ] 是不正确的。 超出了 R 当我们要求 P[i] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [i] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T[R+1] 和 T[R+1]关于 i 的对称点就行了，像解法四一样一个个扩展。 P [ mirror ] 遇到了左边界 此时 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 \"#\" == \"#\" ，之后遇到了 \"^\"和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以接着扩展，就像之前一样。 i 等于了 R 此时我们先把 P [ i ] 赋值为 0 ，然后一步一步扩展就行了。 就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。 此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。 public String preProcess(String s) { int n = s.length(); if (n == 0) { return \"^$\"; } String ret = \"^\"; for (int i = 0; i i) { P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R } else { P[i] = 0;// 等于 R 的情况 } // 碰到之前讲的三种情况时候，需要继续扩展 while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) { P[i]++; } // 判断是否需要更新 R if (i + P[i] > R) { C = i; R = i + P[i]; } } // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i = 1; i maxLen) { maxLen = P[i]; centerIndex = i; } } int start = (centerIndex - maxLen) / 2; //最开始讲的 return s.substring(start, start + maxLen); } 时间复杂度：for 循环里边套了一层 while 循环，难道不是 O ( n² )，不！其实是 O（n）。我们想象一下整个过程，首先外层有一个 for 循环，所以每个字符会遍历一次，而当我们扩展的时候，每次都是从 R + 1 开始扩展，之后又会更新 R 。所以一些字符会遍历两次，但此时这些字符变到 R 的左边，所以不会遍历第三次了，因为我们每次从 R 的右边开始扩展。综上，每个字符其实最多遍历 2 次，所以依旧是线性的，当然如果字符串成为 len ，这里的 n 其实是 2 * len + 3 。所以时间复杂度是 O（n）。 空间复杂度：O（n）。 总结 时间复杂度从三次方降到了一次，美妙！这里两次用到了动态规划去求解，初步认识了动态规划，就是将之前求的值保存起来，方便后边的计算，使得一些多余的计算消失了。并且在动态规划中，通过观察数组的利用情况，从而降低了空间复杂度。而 Manacher 算法对回文串对称性的充分利用，不得不让人叹服，自己加油啦！ "},"leetCode-6-ZigZag-Conversion.html":{"url":"leetCode-6-ZigZag-Conversion.html","title":"6. ZigZag Conversion","keywords":"","body":"题目描述（中等难度） 就是给定一个字符串，然后按写竖着的 「z」的方式排列字符，就是下边的样子。 然后按行的方式输出每个字符，第 0 行，第 1 行，第 2 行 .... 解法一 按照写 Z 的过程，遍历每个字符，然后将字符存到对应的行中。用 goningDown 保存当前的遍历方向，如果遍历到两端，就改变方向。 public String convert(String s, int numRows) { if (numRows == 1) return s; List rows = new ArrayList<>(); for (int i = 0; i 时间复杂度：O（n），n 是字符串的长度。 空间复杂度：O（n），保存每个字符需要的空间。 解法二 找出按 Z 形排列后字符的规律，然后直接保存起来。 我们可以看到，图形其实是有周期的，0，1，2 ... 7 总过 8 个，然后就又开始重复相同的路径。周期的计算就是 cycleLen = 2 × numRows - 2 = 2 × 5 - 2 = 8 个。 我们发现第 0 行和最后一行一个周期内有一个字符，所以第一个字符下标是 0 ，第二个字符下标是 0 + cycleLen = 8，第三个字符下标是 8 + cycleLen = 16 。 其他行都是两个字符。 第 1 个字符和第 0 行的规律是一样的。 第 2 个字符其实就是下一个周期的第 0 行的下标减去当前行。什么意思呢？ 我们求一下第 1 行第 1 个周期内的第 2 个字符，下一个周期的第 0 行的下标是 8 ，减去当前行 1 ，就是 7 了。 我们求一下第 1 行第 2 个而周期内的第 2 个字符，下一个周期的第 0 行的下标是 16 ，减去当前行 1 ，就是 15 了。 我们求一下第 2 行第 1 个周期内的第 2 个字符，下一个周期的第 0 行的下标是 8 ，减去当前行 2 ，就是 6 了。 当然期间一定要保证下标小于 n ，防止越界。 可以写代码了。 public String convert(String s, int numRows) { if (numRows == 1) return s; StringBuilder ret = new StringBuilder(); int n = s.length(); int cycleLen = 2 * numRows - 2; for (int i = 0; i 时间复杂度：O（n），虽然是两层循环，但第二次循环每次加的是 cycleLen ，无非是把每个字符遍历了 1 次，所以两层循环内执行的次数肯定是字符串的长度。 空间复杂度：O（n），保存字符串。 总结 这次算是总结起来最轻松的了，这道题有些找规律的意思。解法一顺着排列的方式遍历，解法二直接从答案入口找出下标的规律。 "},"leetCode-7-Reverse-Integer.html":{"url":"leetCode-7-Reverse-Integer.html","title":"7. Reverse Integer","keywords":"","body":"题目描述（简单难度） 很简单，就是输入整数，输出它的倒置。 第一反应就是， 取余得到个位数，然后除以 10 去掉个位数，然后用一个变量保存倒置的数。 public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; rev = rev * 10 + pop; } return rev; } 然后似乎不是那么理想。 为什么呢？倒置过来不应该是 9646324351 吗。其实题目里讲了，int 的范围是 [−231,231−1][-2^{31} ,2^{31}-1][−2​31​​,2​31​​−1] 也就是 [−2147483648,2147483647][-2147483648,2147483647] [−2147483648,2147483647] 。明显 9646324351 超出了范围，造成了溢出。所以我们需要在输出前，判断是否溢出。 问题的关键就是下边的一句了。 rev = rev * 10 + pop; 为了区分两个 rev ，更好的说明，我们引入 temp 。 temp = rev * 10 + pop; rev = temp; 我们对 temp = rev * 10 + pop; 进行讨论。intMAX = 2147483647 , intMin = - 2147483648 。 对于大于 intMax 的讨论，此时 x 一定是正数，pop 也是正数。 如果 rev > intMax / 10 ，那么没的说，此时肯定溢出了。 如果 rev == intMax / 10 = 2147483647 / 10 = 214748364 ，此时 rev * 10 就是 2147483640 如果 pop 大于 7 ，那么就一定溢出了。但是！如果假设 pop 等于 8，那么意味着原数 x 是 8463847412 了，输入的是 int ，而此时是溢出的状态，所以不可能输入，所以意味着 pop 不可能大于 7 ，也就意味着 rev == intMax / 10 时不会造成溢出。 如果 rev 对于小于 intMin 的讨论同理。 public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev > Integer.MAX_VALUE/10 ) return 0; if (rev 时间复杂度：循环多少次呢？数字有多少位，就循环多少次，也就是 log10(x)+1log_{10}(x) + 1log​10​​(x)+1 次，所以时间复杂度是 O（log（x））。 空间复杂度：O（1）。 当然我们可以不用思考那么多，用一种偷懒的方式 AC ，我们直接把 rev 定义成 long ，然后输出前判断 rev 是不是在范围内，不在的话直接输出 0 。 public int reverse(int x) { long rev = 0; while (x != 0) { int pop = x % 10; x /= 10; rev = rev * 10 + pop; } if (rev > Integer.MAX_VALUE || rev 总结 比较简单的一道题，主要是在考判断是不是溢出，又是轻松的一天！ "},"leetCode-8-String-to-Integer.html":{"url":"leetCode-8-String-to-Integer.html","title":"8. String to Integer","keywords":"","body":" 题目描述（中等难度） 总结 题目描述（中等难度） 将一个字符串转为整型。 这道题，难度其实不大，和上道题有很多重合的地方。整体的思路就是遍历字符串，然后依次取出一个字符就可以了。无非是考虑一些特殊情况，还有就是理解题目意思。 经过多次试错，题目的意思是这样的。 从左遍历字符串，可以遇到空格，直到遇到 ' + ' 或者数字或者 ' - ' 就表示要转换的数字开始，如果之后遇到除了数字的其他字符（包括空格）就结束遍历，输出结果，不管后边有没有数字了，例如 \" - 32332ada2323\" 就输出 \"- 32332\"。 如果遇到空格或者 ' + ' 或者数字或者 ' - ' 之前遇到了其他字符，就直接输出 0 ，例如 \" we1332\"。 如果转换的数字超出了 int ，就返回 intMax 或者 intMin。 public int myAtoi(String str) { int sign = 1; int ans = 0, pop = 0; boolean hasSign = false; //代表是否开始转换数字 for (int i = 0; i = '0' && str.charAt(i) Integer.MAX_VALUE / 10 || (ans * sign == Integer.MAX_VALUE / 10 && pop * sign > 7)) return 2147483647; if (ans * sign 时间复杂度：O（n），n 是字符串的长度。 空间复杂度：O（1）。 总结 这道题让自己有点感到莫名其妙，好像没有 get 到出题人的点？？？ "},"leetCode-9-Palindrome-Number.html":{"url":"leetCode-9-Palindrome-Number.html","title":"9. Palindrome Number","keywords":"","body":" 题目描述（简单难度） 解法一 解法二 解法三 总结 题目描述（简单难度） 判断是不是回文数，负数不是回文数。 解法一 把 int 转成字符串，然后判断是否是回文串做就可以了，缺点是需要额外的空间存储字符串，当然题目也告诉了不能这样，所以 pass 。 解法二 在第 7 道题我们写了倒置 int 的算法，这里当然可以用到了，只需要判断倒置前后相不相等就可以了。 记不记得，当倒置后的数字超出 int 的范围时，我们返回的是 0 ，那么它一定不等于原数，此时一定返回 false 了，这正不正确呢？ 我们只需证明，如果倒置后超出 int 的范围，那么它一定不是回文数字就好了。 反证法，我们假设存在这么一个数，倒置后是超出 int 范围的，并且它是回文数字。 int 最大为 2147483647 , 让我们来讨论这个数可能是多少。 有没有可能是最高位大于 2 导致的溢出，比如最高位是 3 ，因为是回文串，所以最低位是 3 ，这就将导致转置前最高位也会是 3 ，所以不可能是这种情况。 有没有可能是第 2 高位大于 1 导致的溢出，此时保持最高位不变，假如第 2 高位是 2，因为是回文串，所以个位是 2，十位是 2 ，同样的会导致倒置前超出了 int 的最大值，所以也不可能是这种情况。 同理，第 3 高位，第 4，第 5，直线左边的都是上述的情况，所以不可能是前边的位数过大。 为了保证这个数是溢出的，前边 5 位必须固定不变了，因为它是回文串，所以直线后的灰色数字就一定是 4 ，而此时不管后边的数字取多少，都不可能是溢出的了。 综上，不存在这样一个数，所以可以安心的写代码了。 public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev > Integer.MAX_VALUE / 10) return 0; if (rev 时间复杂度：和求转置一样，x 有多少位，就循环多少次，所以是 O（log（x）） 。 空间复杂度：O（1）。 解法三 其实，我们只需要将右半部分倒置然后和左半部比较就可以了。比如 1221 ，把 21 转置和 12 比较就行了。 public boolean isPalindrome(int x) { if (x 时间复杂度：循环 x 的总位数的一半次，所以时间复杂度依旧是 O（log（x））。 空间复杂度：O（1），常数个变量。 总结 这几天都比较简单，加油加油加油！。 "},"leetCode-10-Regular-Expression-Matching.html":{"url":"leetCode-10-Regular-Expression-Matching.html","title":"10. Regular Expression Matching","keywords":"","body":" 题目描述（困难难度） 解法一 递归 解法二 动态规划 总 题目描述（困难难度） 一个简单规则的匹配，「点.」代表任意字符，「星号*」 代表前一个字符重复 0 次或任意次。 解法一 递归 假如没有通配符 * ，这道题的难度就会少了很多，我们只需要一个字符，一个字符匹配就行。如果对递归不是很了解，强烈建议看下这篇文章，可以理清一下递归的思路。 我们假设存在这么个函数 isMatch，它将告诉我们 text 和 pattern 是否匹配 boolean isMatch ( String text, String pattern ) ; 递归规模减小 text 和 pattern 匹配，等价于 text 和 patten 的第一个字符匹配并且剩下的字符也匹配，而判断剩下的字符是否匹配，我们就可以调用 isMatch 函数。也就是 (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')&&isMatch(text.substring(1), pattern.substring(1)); 递归出口 随着规模的减小， 当 pattern 为空时，如果 text 也为空，就返回 True，不然的话就返回 False 。 if (pattern.isEmpty()) return text.isEmpty(); 综上，我们的代码是 public boolean isMatch(String text, String pattern) { if (pattern.isEmpty()) return text.isEmpty(); //判断 text 是否为空，防止越界，如果 text 为空， 表达式直接判为 false, text.charAt(0)就不会执行了 boolean first_match = (!text.isEmpty() && (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')); return first_match && isMatch(text.substring(1), pattern.substring(1)); } 当我们考虑了 * 呢，对于递归规模的减小，会增加对于 * 的判断，直接看代码吧。 public boolean isMatch(String text, String pattern) { if (pattern.isEmpty()) return text.isEmpty(); boolean first_match = (!text.isEmpty() && (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')); //只有长度大于 2 的时候，才考虑 * if (pattern.length() >= 2 && pattern.charAt(1) == '*'){ //两种情况 //pattern 直接跳过两个字符。表示 * 前边的字符出现 0 次 //pattern 不变，例如 text = aa ，pattern = a*，第一个 a 匹配，然后 text 的第二个 a 接着和 pattern 的第一个 a 进行匹配。表示 * 用前一个字符替代。 return (isMatch(text, pattern.substring(2)) || (first_match && isMatch(text.substring(1), pattern))); } else { return first_match && isMatch(text.substring(1), pattern.substring(1)); } } 时间复杂度：有点儿小复杂，待更。 空间复杂度：有点儿小复杂，待更。 解法二 动态规划 上边的递归，为了方便理解，简化下思路。 为了判断 text [ 0，len ] 的情况，需要知道 text [ 1，len ] 为了判断 text [ 1，len ] 的情况，需要知道 text [ 2，len ] 为了判断 text [ 2，len ] 的情况，需要知道 text [ 3，len ] ... 为了判断 text [ len - 1，len ] 的情况，需要知道 text [ len，len ] text [ len，len ] 肯定好求 求出 text [ len，len ] 的情况，就知道了 text [ len - 1，len ] 求出 text [ len - 1，len ] 的情况，就知道了 text [ len - 2，len ] ... 求出 text [ 2，len ] 的情况，就知道了 text [1，len ] 求出 text [ l1，len ] 的情况，就知道了 text [ 0，len ] 从而知道了 text [ 0，len ] 的情况，求得问题的解。 上边就是先压栈，然后出栈，其实我们可以直接倒过来求，可以省略压栈的过程。 我们先求 text [ len，len ] 的情况 利用 text [ len，len ] 的情况 ，再求 text [ len - 1，len ] 的情况 ... 利用 text [ 2，len ] 的情况 ，再求 text [ 1，len ] 的情况 利用 text [1，len ] 的情况 ，再求 text [ 0，len ] 的情况 从而求出问题的解 我们用 dp[i][j]dp[i][j]dp[i][j]表示 text 从 i 开始到最后，pattern 从 j 开始到最后，此时 text 和 pattern 是否匹配。 dp[2][2]dp[2][2]dp[2][2]就是图中橙色的部分. public boolean isMatch(String text, String pattern) { // 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况， // 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了 boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1]; // dp[len][len] 代表两个空串是否匹配了，\"\" 和 \"\" ，当然是 true 了。 dp[text.length()][pattern.length()] = true; // 从 len 开始减少 for (int i = text.length(); i >= 0; i--) { for (int j = pattern.length(); j >= 0; j--) { // dp[text.length()][pattern.length()] 已经进行了初始化 if(i==text.length()&&j==pattern.length()) continue; boolean first_match = (i 时间复杂度：假设 text 的长度是 T，pattern 的长度是 P ，空间复杂度就是 O（TP）。 空间复杂度：申请了 dp 空间，所以是 O（TP），因为每次循环我们只需要知道 i 和 i + 1 时候的情况，所以我们可以向 第 5 题 一样进行优化。 public boolean isMatch(String text, String pattern) { // 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况， // 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了 boolean[][] dp = new boolean[2][pattern.length() + 1]; dp[text.length()%2][pattern.length()] = true; // 从 len 开始减少 for (int i = text.length(); i >= 0; i--) { for (int j = pattern.length(); j >= 0; j--) { if(i==text.length()&&j==pattern.length()) continue; boolean first_match = (i 时间复杂度：不变， O（TP）。 空间复杂度：主要用了两个数组进行轮换，O（P）。 总 这道题对于递归的解法，感觉难在怎么去求时间复杂度，现在还没有什么思路，以后再来补充吧。整体来说，只要理清思路，两种算法还是比较好理解的。 "},"leetCode-11-Container-With-Most-Water.html":{"url":"leetCode-11-Container-With-Most-Water.html","title":"11. Container With Most Water","keywords":"","body":" 题目描述（中等难度） 解法一 暴力解法 解法二 总 题目描述（中等难度） 每个数组代表一个高度，选两个任意的柱子往里边倒水，能最多倒多少水。 解法一 暴力解法 直接遍历任意两根柱子，求出能存水的大小，用一个变量保存最大的。 public int maxArea(int[] height) { int max = 0; for (int i = 0; i max) { max = h * (j - i); } } } return max; } 时间复杂度：O（n²）。 空间复杂度：O（1）。 解法二 我们理一下思路，大小是由长度和高度决定，如果选 0 到 8 就保证了长度最长，此时大小是 0 号柱子的高度 1 乘以长度 8 。我们如果想面积更大怎么做呢，只能减小长度，增加高度。是左边的柱子向右移动变成 1 号柱子呢？还是右边的柱子向左移动变成 7 号柱子呢？当然是哪边的柱子短就改哪边的！只有这样，高度才有可能增加。 例如我们如果把 8 号柱子变成 7 号柱子，此时长度减少了，然而高度还是 0 号柱子没有变化，所以面积就会减少。把 1 号柱子变成 2 号柱子就很好了，因为此时高度就变成了 8 号柱子的高度，面积就有可能会增加。 如果左右两边柱子相等该怎么办呢？随意！ 我们假设 1 号 和 8 号 柱子高度是相等的。如果他们之间的柱子只有 1 根比它俩高或者没有比它俩高的，那么最大面积就一定选取是 1 号和 8 号了，所以 1 号接着变大，或者 8 号接着减小都是无所谓的，因为答案已经确定了。 假设 1 号 和 8 号之间有 2 根或以上的柱子比它俩高，假设是 4 号和 6 号比它俩高。1 号会变到 2 号、3 号，最终为 4 号，8 号会变到 7 号， 6 号，而在这个过程中产生的面积一定不会比 1 号和 8 号产生的面积大，因为过程中的柱子都比 1 号和 8 号低。所以是先变 1 号还是先变 8 号是无所谓的，无非是谁先到达更长的柱子而已。 看一下下边的算法，会更加清楚一些。 public int maxArea2(int[] height) { int maxarea = 0, l = 0, r = height.length - 1; while (l 时间复杂度：O（n）。 空间复杂度：O（1）。 总 为了减少暴力解法的时间复杂度，只能去深层次的理解题意，从而找出突破点。 "},"leetCode-12-Integer-to-Roman.html":{"url":"leetCode-12-Integer-to-Roman.html","title":"12. Integer to Roman","keywords":"","body":" 题目描述（中等难度） 解法一 解法二 解法三 总 题目描述（中等难度） 把数字转换成罗马数字，正常情况就是把每个字母相加，并且大字母在前，小字母在后，上边也介绍了像 4 和 9 那些特殊情况。 解法一 这个是自己的解法，主要思想就是每次取出一位，然后得到相应的罗马数字，然后合起来就行。 public String getRoman(int num,int count){ //count 表示当前的位数，个位，十位... char[]ten={'I','X','C','M'}; //1,10,100,1000 char[]five={'V','L','D'};//5,50,500 String r=\"\"; if(num5&&num 时间复杂度：num 的位数 log10(num)+1log_{10}(num)+1log​10​​(num)+1所以时间复杂度是 O（log（n））。 空间复杂度：常数个变量，O（1）。 下边在分享一些 LeetCode 讨论里的一些解法。 解法二 https://leetcode.com/problems/integer-to-roman/discuss/6310/My-java-solution-easy-to-understand public String intToRoman(int num) { int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}; String[] strs = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"}; StringBuilder sb = new StringBuilder(); for(int i=0;i= values[i]) { num -= values[i]; sb.append(strs[i]); } } return sb.toString(); } 相当简洁了，主要就是把所有的组合列出来，因为罗马数字表示的大小就是把所有字母相加，所以每次 append 那个，再把对应的值减去就行了。 时间复杂度：不是很清楚，也许是 O（1）？因为似乎和问题规模没什么关系了。 空间复杂度：O（1）. 解法三 https://leetcode.com/problems/integer-to-roman/discuss/6376/Simple-JAVA-solution public String intToRoman(int num) { String M[] = {\"\", \"M\", \"MM\", \"MMM\"};//0,1000,2000,3000 String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};//0,100,200,300... String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};//0,10,20,30... String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};//0,1,2,3... return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10]; } 这就更加暴力了，把每位的情况都列出来然后直接返回，但思路清晰明了呀。 时间复杂度：O（1）或者说是 num 的位数，不是很确定。 空间复杂度：O（1）。 总 这道题感觉难度应该是 easy ，没有那么难，就是理清楚题意，然后就可以往出列举就行了。 "},"leetCode-13-Roman-to-Integer.html":{"url":"leetCode-13-Roman-to-Integer.html","title":"13. Roman to Integer","keywords":"","body":" 题目描述（简单难度） 解法一 解法二 解法三 总 题目描述（简单难度） 和上一道题相反，将罗马数字转换成阿拉伯数字。 解法一 先来一种不优雅的，也就是我开始的想法。就是遍历字符串，然后转换就可以，但同时得考虑 IV，IX 那些特殊情况。 public int getInt(char r) { int ans = 0; switch (r) { case 'I': ans = 1; break; case 'V': ans = 5; break; case 'X': ans = 10; break; case 'L': ans = 50; break; case 'C': ans = 100; break; case 'D': ans = 500; break; case 'M': ans = 1000; } return ans; } public int getInt(char r, char r_after) { int ans = 0; switch (r) { case 'I': ans = 1; break; case 'V': ans = 5; break; case 'X': ans = 10; break; case 'L': ans = 50; break; case 'C': ans = 100; break; case 'D': ans = 500; break; case 'M': ans = 1000; break; } if (r == 'I') { switch (r_after) { case 'V': ans = 4; break; case 'X': ans = 9; } } if (r == 'X') { switch (r_after) { case 'L': ans = 40; break; case 'C': ans = 90; } } if (r == 'C') { switch (r_after) { case 'D': ans = 400; break; case 'M': ans = 900; } } return ans; } public boolean isGetTwoInt(char r, char r_after) { if (r == 'I') { switch (r_after) { case 'V': return true; case 'X': return true; } } if (r == 'X') { switch (r_after) { case 'L': return true; case 'C': return true; } } if (r == 'C') { switch (r_after) { case 'D': return true; case 'M': return true; } } return false; } public int romanToInt(String s) { int ans = 0; for (int i = 0; i = 2 && isGetTwoInt(s.charAt(s.length() - 2), s.charAt(s.length() - 1)))) { ans += getInt(s.charAt(s.length() - 1)); } return ans; } 时间复杂度：O（n），n 是字符串的长度。 空间复杂度：O（1）。 下边分享一些优雅的。 解法二 https://leetcode.com/problems/roman-to-integer/description/ public int romanToInt(String s) { int sum=0; if(s.indexOf(\"IV\")!=-1){sum-=2;} if(s.indexOf(\"IX\")!=-1){sum-=2;} if(s.indexOf(\"XL\")!=-1){sum-=20;} if(s.indexOf(\"XC\")!=-1){sum-=20;} if(s.indexOf(\"CD\")!=-1){sum-=200;} if(s.indexOf(\"CM\")!=-1){sum-=200;} char c[]=s.toCharArray(); int count=0; for(;count 把出现的特殊情况，提前减了就可以。 时间复杂度：O（1）。 空间复杂度：O（1）。 解法三 https://leetcode.com/problems/roman-to-integer/discuss/6509/7ms-solution-in-Java.-easy-to-understand 利用到罗马数字的规则，一般情况是表示数字大的字母在前，数字小的字母在后，如果不是这样，就说明出现了特殊情况，此时应该做减法。 private int getVal(char c){ switch (c){ case 'M': return 1000; case 'D': return 500; case 'C': return 100; case 'L': return 50; case 'X' : return 10; case 'V': return 5; case 'I': return 1; } throw new IllegalArgumentException(\"unsupported character\"); } public int romanToInt(String s) { int res = 0; if(s.length() == 0) return res; for (int i = 0; i 时间复杂度：O（1）。 空间复杂度：O（1）。 总 这道题也不难，自己一开始没有充分利用罗马数字的特点，而是用一些 if，switch 语句判断是否是特殊情况，看起来就很繁琐了。 "},"leetCode-14-Longest-Common-Prefix.html":{"url":"leetCode-14-Longest-Common-Prefix.html","title":"14. Longest Common Prefix","keywords":"","body":" 题目描述（简单难度） 解法一 垂直比较 解法二 水平比较 解法三 递归 总 题目描述（简单难度） 解法一 垂直比较 我们把所有字符串垂直排列，然后一列一列的比较，直到某一个字符串到达结尾或者该列字符不完全相同。 下边看一下我的代码，看起来比较多 //这个函数判断 index 列的字符是否完全相同 public boolean isSameAtIndex(String[] strs, int index) { int i = 0; while (i 下边看一下，官方的代码 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; //遍历所有列 for (int i = 0; i 时间复杂度：最坏的情况就是 n 个 长度为 m 的完全一样的字符串，假设 S 是所有字符的和，那么 S = m * n，时间复杂度就是 O（S）。当然正常情况下并不需要比较所有字符串，最多比较 n * minLen 个字符就可以了。 空间复杂度：O（1），常数个额外空间。 解法二 水平比较 我们将字符串水平排列，第 0 个和第 1 个字符串找最长子串，结果为 leet，再把结果和第 2 个字符串比较，结果为 leet，再把结果和第 3 个字符串比较，结果为 lee，即为最终结果。 public String longestCommonPrefix3(String[] strs) { if (strs.length == 0) return \"\"; String prefix = strs[0]; // 保存结果 // 遍历每一个字符串 for (int i = 1; i 时间复杂度：最坏情况和解法一是一样，n 个长度为 m 的完全相同的字符，就要比较所有的字符 S，S = n * m 。但对于正常情况，处于最短字符串前的字符串依旧要比较所有字符，而不是最短字符串个字符，相对于解法一较差。 空间复杂度：O（1）。 解法三 递归 我们把原来的数组分成两部分，求出左半部分的最长公共前缀，求出右半部分的最长公共前缀，然后求出的两个结果再求最长公共前缀，就是最后的结果了。 求左半部分的最长公共前缀，我们可以继续把它分成两部分，按照上边的思路接着求。然后一直分成两部分，递归下去。 直到该部分只有 1 个字符串，那么最长公共子串就是它本身了，直接返回就可以了。 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; return longestCommonPrefix(strs, 0 , strs.length - 1); } //递归不断分成两部分 private String longestCommonPrefix(String[] strs, int l, int r) { if (l == r) { return strs[l]; } else { int mid = (l + r)/2; String lcpLeft = longestCommonPrefix(strs, l , mid); String lcpRight = longestCommonPrefix(strs, mid + 1,r); return commonPrefix(lcpLeft, lcpRight); } } //求两个结果的最长公共前缀 String commonPrefix(String left,String right) { int min = Math.min(left.length(), right.length()); for (int i = 0; i 时间复杂度： 空间复杂度： 每次遇到递归的情况，总是有些理不清楚，先空着吧。 总 进行了垂直比较和水平比较，又用到了递归，solution 里还介绍了二分查找，感觉这里用二分查找有些太僵硬了，反而使得时间复杂度变高了。还介绍了前缀树，这里后边遇到再总结吧。 "},"leetCode-15-3Sum.html":{"url":"leetCode-15-3Sum.html","title":"15. 3Sum","keywords":"","body":" 题目描述（中等难度） 解法一 暴力解法 解法二 总 题目描述（中等难度） 解法一 暴力解法 无脑搜索，三层循环，遍历所有的情况。但需要注意的是，我们需要把重复的情况去除掉，就是 [1, -1 ,0] 和 [0, -1, 1] 是属于同一种情况的。 public List> threeSum(int[] nums) { List> res = new ArrayList>(); for (int i = 0; i temp = new ArrayList(); temp.add(nums[i]); temp.add(nums[j]); temp.add(nums[k]); //判断结果中是否已经有 temp 。 if (isInList(res, temp)) { continue; } res.add(temp); } } } return res; } public boolean isInList(List> l, List a) { for (int i = 0; i a, List b) { int count = 0; Collections.sort(a); Collections.sort(b); //排序后判断每个元素是否对应相等 for (int i = 0; i 时间复杂度：n 表示 num 的个数，三个循环 O（n³），而 isInList 也需要 O（n），总共就是 O(n4)O(n^4)O(n​4​​)，leetCode 复杂度到了 O(n3)O(n^3)O(n​3​​) 一般就报超时错误了，所以算法还得优化。 空间复杂度：最坏情况，即 O（N）, N 是指 n 个元素的排列组合个数，即 N=Cn3N=C^3_nN=C​n​3​​，用来保存结果。 解法二 参考了这里-Java-solution) 主要思想是，遍历数组，用 0 减去当前的数，作为 sum ，然后再找两个数使得和为 sum。 这样看来遍历需要 O（n），再找两个数需要 O（n²）的复杂度，还是需要 O（n³）。 巧妙之处在于怎么找另外两个数。 最最优美的地方就是，首先将给定的 num 排序。 这样我们就可以用两个指针，一个指向头，一个指向尾，去找这两个数字，这样的话，找另外两个数时间复杂度就会从 O（n²），降到 O（n）。 而怎么保证不加入重复的 list 呢？ 要记得我们的 nums 已经有序了，所以只需要找到一组之后，当前指针要移到和当前元素不同的地方。其次在遍历数组的时候，如果和上个数字相同，也要继续后移。文字表述比较困难，可以先看下代码。 public List> threeSum(int[] num) { Arrays.sort(num); //排序 List> res = new LinkedList<>(); for (int i = 0; i 0 && num[i] != num[i-1])) { //两个指针,并且头指针从i + 1开始，防止加入重复的元素 int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo 时间复杂度：O（n²），n 指的是 num 空间复杂度：O（N），最坏情况，即 N 是指 n 个元素的排列组合个数，即 N=Cn3N=C^3_nN=C​n​3​​，用来保存结果。 总 对于遍历，这里用到了从两头同时遍历，从而降低了时间复杂度，很妙！ "},"leetCode-16-3Sum-Closest.html":{"url":"leetCode-16-3Sum-Closest.html","title":"16. 3Sum Closest","keywords":"","body":" 题目描述（中等难度） 解法一 暴力解法 解法二 总 题目描述（中等难度） 和上一道题很类似，只不过这个是给一个目标值，找三个数，使得他们的和最接近目标值。 解法一 暴力解法 遍历所有的情况，然后求出三个数的和，和目标值进行比较，选取差值最小的即可。本以为时间复杂度太大了，神奇的是，竟然 AC 了。 public int threeSumClosest(int[] nums, int target) { int sub = Integer.MAX_VALUE; //保存和 target 的差值 int sum = 0; //保存当前最接近 target 的三个数的和 for (int i = 0; i 时间复杂度：O（n³），三层循环。 空间复杂度：O（1），常数个。 解法二 受到上一题的启发，没有看的，推荐大家可以看一下。我们完全可以先将数组排序，然后先固定一个数字，然后利用头尾两个指针进行遍历，降低一个 O（n）的时间复杂度。 如果 sum 大于 target 就减小右指针，反之，就增加左指针。 public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int sub=Integer.MAX_VALUE; int sum=0; for(int i=0;itarget){ hi--; }else{ lo++; } } } return sum; } 时间复杂度：如果是快速排序的 O(logn)O(log_n)O(log​n​​) 再加上 O（n²），所以就是 O（n²）。 空间复杂度：O（1）。 总 和上一道题非常非常的相似了，先对数组排序，然后利用两头的指针，可以说是十分的优雅了。 "},"leetCode-17-Letter-Combinations-of-a-Phone-Number.html":{"url":"leetCode-17-Letter-Combinations-of-a-Phone-Number.html","title":"17. Letter Combinations of a Phone Number","keywords":"","body":" 题目描述（中等难度） 解法一 定义相乘 解法二 队列迭代 解法三 递归 总 题目描述（中等难度） 给一串数字，每个数可以代表数字键下的几个字母，返回这些数字下的字母的所有组成可能。 解法一 定义相乘 自己想了用迭代，用递归，都理不清楚，灵机一动，想出了这个算法。 把字符串 \"23\" 看成 [\"a\",\"b\",c] * [\"d\",\"e\",\"f\"] ，而相乘就用两个 for 循环实现即可，看代码应该就明白了。 public List letterCombinations(String digits) { List ans = new ArrayList(); for (int i = 0; i getList(int digit) { String digitLetter[] = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; List ans = new ArrayList(); for (int i = 0; i mul(List l1, List l2) { if (l1.size() != 0 && l2.size() == 0) { return l1; } if (l1.size() == 0 && l2.size() != 0) { return l2; } List ans = new ArrayList(); for (int i = 0; i 解法二 队列迭代 参考这里，果然有人用迭代写了出来。主要用到了队列。 public List letterCombinations(String digits) { LinkedList ans = new LinkedList(); if(digits.isEmpty()) return ans; String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; ans.add(\"\"); for(int i =0; i 假如是 \"23\" ，那么 第 1 次 for 循环结束后变为 a, b, c； 第 2 次 for 循环的第 1 次 while 循环 a 出队，分别加上 d e f 然后入队，就变成 b c ad ae af 第 2 次 for 循环的第 2 次 while 循环 b 出队，分别加上 d e f 然后入队，就变成 c ad ae af bd be bf 第 2 次 for 循环的第 3 次 while 循环 c 出队，分别加上 d e f 然后入队，就变成 ad ae af bd be bf cd ce cf 这样的话队列的元素长度再也没有等于 1 的了就出了 while 循环。 解法三 递归 参考这里 private static final String[] KEYS = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; public List letterCombinations(String digits) { if(digits.equals(\"\")) { return new ArrayList(); } List ret = new LinkedList(); combination(\"\", digits, 0, ret); return ret; } private void combination(String prefix, String digits, int offset, List ret) { //offset 代表在加哪个数字 if (offset == digits.length()) { ret.add(prefix); return; } String letters = KEYS[(digits.charAt(offset) - '0')]; for (int i = 0; i 从 a 开始 ，然后递归到 d ，然后 g ，就把 adg 加入，然后再加入 adh，再加入 adi ... 从左到右，递归到底之后就将其加入。 总 这种题的时间复杂度和空间复杂度自己理的不太清楚就没有写了。 "},"leetCode-18-4Sum.html":{"url":"leetCode-18-4Sum.html","title":"18. 4Sum","keywords":"","body":" 题目描述（中等难度） 总 题目描述（中等难度） 和3Sum类似，只不过是找四个数，使得和为 target，并且不能有重复的序列。 如果之前没有做过3Sum可以先看看，自己在上边的基础上加了一个循环而已。 public List> fourSum(int[] num, int target) { Arrays.sort(num); List> res = new LinkedList<>(); //多加了层循环 for (int j = 0; j 0 && num[j] != num[j - 1])) for (int i = j + 1; i 时间复杂度：O（n³）。 空间复杂度：O（N），最坏情况，即 N 是指 n 个元素的排列组合个数，即 N=Cn4N=C^4_nN=C​n​4​​，用来保存结果。 总 完全是按照 3Sum 的思路写的，比较好理解。 "},"leetCode-79-Word-Search.html":{"url":"leetCode-79-Word-Search.html","title":"79. Word Search","keywords":"","body":" 题目描述（中等难度） 总 题目描述（中等难度） 意思就是从某个字符出发，然后它可以向左向右向上向下移动，走过的路径构成一个字符串，判断是否能走出给定字符串的 word ，还有一个条件就是走过的字符不能够走第二次。 比如 SEE，从第二行最后一列的 S 出发，向下移动，再向左移动，就走出了 SEE。 ABCB，从第一行第一列的 A 出发，向右移动，再向右移动，到达 C 以后，不能向左移动回到 B ，并且也没有其他的路径走出 ABCB 所以返回 false。 这种题，如果用迭代一眼想不到结果，就得考虑递归或者动态规划的方法了。 而递归的话，一定要理清我们的思路，我一般用三步走的思路，可以看下这里 第一步，假定我们有这么个函数 boolean isExist(int current_i,int current_j,String word,char[][]board) 从第 current_i 行和第 current_j 列的字符开始，是否能找到 word 的路径。 第二步，我们要理清楚，怎么从降低规模 我们只需要知道从第 current_i 行和第 current_j 列的字符开始，看能否找到 word 的第一个字符，假如找到的字符的位置是 new_i，new_j，那么我们只要再知道 isExist ( new_i，new_j，word.substring(1),board) 返回值就可以了，也就是从新的位置开始，能否找到除去 word 的第一个字符的字符串。 怎么从第 current_i 和第 current_j 开始，找到 word 的第一个字符，我只需要分别判断第 current_i 行和第 current_j 列的字符的上边、下边、左边、右边的字符是否等于 word 的第一个字符就可以了。 第三步，递归出口 如果传进来的 word 长度是 0 了，我们只需要返回 true 就可以了。 递归思路理清了，还有一个问题就是，怎么保证不重复选取字符，我们利用一个和 board 等大的数组 visited，保存每个字符是否被选上就可以了。 static boolean[][] visited; public boolean exist(char[][] board, String word) { visited = new boolean[board.length][board[0].length];//默认初始值是 false for (int i = 0; i =0&&board[current_i-1][current_j]==word.charAt(0)&&!visited[current_i-1][current_j] &&isExist(current_i-1,current_j,word.substring(1),board); boolean bottom=current_i+1=0&&board[current_i][current_j-1]==word.charAt(0)&&!visited[current_i][current_j-1] &&isExist(current_i,current_j-1,word.substring(1),board); boolean right=current_j+1 时间复杂度：递归的，暂时理不清。 空间复杂度：O（m * n），m 是 board 的行数，n 是 board 的列数。 看到了 leetCode 上一个人的解答，简直神奇！他把空间复杂度优化到了常数空间，怎么做的呢？ 就是把选中的字符的值，改成一个不可能和其他字符相等的值，这样在找和 word 的第一个字符相等的字符的时候，就永远不会找到之前选中的字符了。 开始假设字符被选中的时候，我们将其改成 board[current_i][current_j]='#' 这样到最后，如果它没被选中就还原，怎么还原？原来的值似乎找不到了，所以我们应该找一种可逆的操作。 我们可以用异或，因为字符值的范围是 0 - 255，二进制的话就是 0000 0000 - 1111 1111，我们把它和 256 做异或，也就是和 1 0000 0000 。这样，如果想还原原来的数字只需要再异或 256 就可以了。 看起来有些复杂，其实我们也可以假设选中的时候，把它加上 256，这样它就不可能和其他字符相等了。如果假设失败了，再减去 256 就还原为原来的数字了。 public boolean exist(char[][] board, String word) { visited = new boolean[board.length][board[0].length];//默认初始值是 false for (int i = 0; i =0&&board[current_i-1][current_j]==word.charAt(0) &&isExist(current_i-1,current_j,word.substring(1),board); boolean bottom=current_i+1=0&&board[current_i][current_j-1]==word.charAt(0) &&isExist(current_i,current_j-1,word.substring(1),board); boolean right=current_j+1 总 这种题基本是算法模仿选择的过程就行了，关键就是把问题理清。异或操作优化了空间复杂度，真的佩服！ "}}
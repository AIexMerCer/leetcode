# 题目描述（困难难度）

![](https://windliang.oss-cn-beijing.aliyuncs.com/72.jpg)

由一个字符串变为另一个字符串的最少操作次数，可以删除一个字符，替换一个字符，插入一个字符。

# 解法一

首先，我们可以发现删除一个字符和插入一个字符是等效的，对于变换次数并没有影响。例如 "a"  和 "ab" ，既可以 "a" 加上一个字符 "b" 变成 "ab"，也可以是 "ab" 去掉一个字符 "b" 变成 "a"。所以下边的算法可以只考虑插入和替换。

利用动态规划的思想，关键就是定义出状态转移方程。依旧是假设我们解决了小问题，怎么推导出大问题的答案。假如，我们要求"abc" 和 "bc" 的最小编辑距离。如果我们已经知道了 "ab" 和 "bc" 的最小编辑距离，"abc" 和 "b" 的最小编辑距离，"ab" 和 "b" 的最小编辑距离。

对于这种字符串，我们直接定义一个二维数组。

假设两个字符串是 word1 和 word2。

ans\[i\]\[j\] 来表示字符串 word1[ 0, i ]  （word1 的第 0 到 第 i 个字符）和 word2[ 0, j ] 的最短编辑距离。然后状态转移方程就出来了。

if ( word1[m] == word2[n] )

​    ans\[m\]\[n\] = Math.min ( ans[m]\[n-1\] + 1,  ans[m-1]\[n\] + 1,  ans[m-1]\[n-1\]）

if ( word1[m] != word2[n] )

​    ans\[m\]\[n\] = Math.min ( ans[m]\[n-1\] + 1,  ans[m-1]\[n\] + 1,  ans[m-1]\[n-1\] + 1）

其中，ans[m]\[n-1\] + 1,  ans[m-1]\[n\] + 1 ，加 1 代表进行插入操作，使得两个字符串相等。很好理解，比如知道了 "abc" 和 "bc" 的最小编辑距离是 1。那么  "abcd" 和 "bc" 的最小编辑距离可能是 



而 ans[m-1]\[n-1\] 是否相等取决于  word1[m] 是否等于 word2[n]，等于的话就不需要加 1 了。

